////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2023 Qualcomm Technologies, Inc.
// All Rights Reserved.
// Confidential and Proprietary - Qualcomm Technologies, Inc.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// THIS IS AUTO-GENERATED CODE.  PLEASE DO NOT EDIT (File bug reports against tools).
///
/// Auto-generated by: Parameter Parser V2.0.0 (1907311625)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file  aecflash.cpp
/// @brief Auto-generated Chromatix parameter file
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "aecflash.h"
#include "parametersetmanager.h"

AECFLASH_NAMESPACE_BEGIN

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Default Constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
AECFlashTypeClass::AECFlashTypeClass(
    const CHAR* name)
    : ParameterModule(name, VersionUnion(MAJOR, MINOR, PATCH), 0, ModeUnion(0))
{
    PARAMETER_INITIALIZE(SymbolTableID);
    PARAMETER_INITIALIZE(module_version);
    PARAMETER_INITIALIZE(parameter_version);
    PARAMETER_INITIALIZE(flashMtr);
    PARAMETER_INITIALIZE(flashConv);
    PARAMETER_INITIALIZE(flashArb);
    PARAMETER_INITIALIZE(flashExt);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
AECFlashTypeClass::AECFlashTypeClass(
    const CHAR* name,
    UINT32      modeId,
    ModeUnion   mode)
    : ParameterModule(name, VersionUnion(MAJOR, MINOR, PATCH), modeId, mode)
{
    PARAMETER_INITIALIZE(SymbolTableID);
    PARAMETER_INITIALIZE(module_version);
    PARAMETER_INITIALIZE(parameter_version);
    PARAMETER_INITIALIZE(flashMtr);
    PARAMETER_INITIALIZE(flashConv);
    PARAMETER_INITIALIZE(flashArb);
    PARAMETER_INITIALIZE(flashExt);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Destructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
AECFlashTypeClass::~AECFlashTypeClass()
{
    UnloadAECFlashType(this);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GetName
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const CHAR* AECFlashTypeClass::GetName(
    const CHAR* type)
{
    const CHAR* name = type;
    CHAR temp[ParameterFileSymbolTableEntry::TYPE_LEN + 1];
    if (PARAMETER_STRCMP(type, ParameterFileSymbolTableEntry::GetType(temp, "Flash")) == 0)
    {
        name = "Flash";
    }
    return name;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load LEDInlineCalibTargetDataType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadLEDInlineCalibTargetDataType(
    ParameterFileSymbolTableEntry* entry,
    LEDInlineCalibTargetDataType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->distancePCT, alignment);
    result = result && entry->Read(&structure->angleShiftPCT, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load LEDInlineCalibTargetZoneType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadLEDInlineCalibTargetZoneType(
    ParameterFileSymbolTableEntry* entry,
    LEDInlineCalibTargetZoneType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = aecglobalelements::aecglobalelementsClass::LoadTriggerPointType(entry, &structure->zoneTrigger, alignment);
    result = result && LoadLEDInlineCalibTargetDataType(entry, &structure->zoneData, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load LEDInlineCalibTargetType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadLEDInlineCalibTargetType(
    ParameterFileSymbolTableEntry* entry,
    LEDInlineCalibTargetType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading Array LEDInlineCalibTargetZone from symbol table
    {
        result = entry->Read(&structure->LEDInlineCalibTargetZoneCount, alignment);
        structure->LEDInlineCalibTargetZoneID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->LEDInlineCalibTargetZone = PARAMETER_NEW LEDInlineCalibTargetZoneType[structure->LEDInlineCalibTargetZoneCount];
        }
        if (!result || structure->LEDInlineCalibTargetZone == NULL)
        {
            structure->LEDInlineCalibTargetZoneCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->LEDInlineCalibTargetZoneCount; i++)
        {
            result = LoadLEDInlineCalibTargetZoneType(pointerEntry, &structure->LEDInlineCalibTargetZone[i], alignment);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load LEDInlineCalibType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadLEDInlineCalibType(
    ParameterFileSymbolTableEntry* entry,
    LEDInlineCalibType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->triggerIndex, alignment);
    result = result && entry->Read(&structure->refRange, alignment);
    result = result && entry->Read(&structure->refRegionPCT, alignment);
    result = result && entry->Read(&structure->validRefCount, alignment);
    result = result && entry->Read(&structure->distanceRatioMin, alignment);
    result = result && entry->Read(&structure->distanceRatioMax, alignment);
    result = result && entry->Read(&structure->angleShiftMax, alignment);
    result = result && entry->Read(&structure->minKneeCnt, alignment);
    result = result && entry->Read(&structure->maxZoneCnt, alignment);
    result = result && entry->Read(&structure->confidencePctThr, alignment);
    result = result && entry->Read(&structure->numOfFactoringRegions, alignment);
    result = result && LoadLEDInlineCalibTargetType(entry, &structure->LEDInlineCalibTarget, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load LEDMeasurementType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadLEDMeasurementType(
    ParameterFileSymbolTableEntry* entry,
    LEDMeasurementType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->frameErrAllowance, alignment);
    result = result && entry->Read(&structure->numOfFrames, alignment);
    result = result && entry->Read(&structure->maxNumOfFrames, alignment);
    result = result && entry->Read(&structure->maxNumOfExtraAttempts, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load LEDRatioOkRangeType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadLEDRatioOkRangeType(
    ParameterFileSymbolTableEntry* entry,
    LEDRatioOkRangeType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = aecglobalelements::aecglobalelementsClass::LoadStartEndType(entry, &structure->RGRatioOKRange, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadStartEndType(entry, &structure->BGRatioOKRange, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load LEDMixCalibEntryType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadLEDMixCalibEntryType(
    ParameterFileSymbolTableEntry* entry,
    LEDMixCalibEntryType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->LEDPowerIndex, alignment);
    result = result && entry->Read(&structure->LEDMixIndex, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load LEDMixCalibType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadLEDMixCalibType(
    ParameterFileSymbolTableEntry* entry,
    LEDMixCalibType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->numOfCalibration, alignment);
    result = result && entry->Read(&structure->enableCornerSampleScreen, alignment);

    // Reading Array calibEntries from symbol table
    {
        result = result && entry->Read(&structure->calibEntriesCount, alignment);
        structure->calibEntriesID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->calibEntries = PARAMETER_NEW LEDMixCalibEntryType[structure->calibEntriesCount];
        }
        if (!result || structure->calibEntries == NULL)
        {
            structure->calibEntriesCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->calibEntriesCount; i++)
        {
            result = LoadLEDMixCalibEntryType(pointerEntry, &structure->calibEntries[i], alignment);
        }
    }

    // Reading Array statsRatioOKRange from symbol table
    {
        result = result && entry->Read(&structure->statsRatioOKRangeCount, alignment);
        structure->statsRatioOKRangeID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->statsRatioOKRange = PARAMETER_NEW LEDRatioOkRangeType[structure->statsRatioOKRangeCount];
        }
        if (!result || structure->statsRatioOKRange == NULL)
        {
            structure->statsRatioOKRangeCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->statsRatioOKRangeCount; i++)
        {
            result = LoadLEDRatioOkRangeType(pointerEntry, &structure->statsRatioOKRange[i], alignment);
        }
    }

    // Reading Array fixedExpIndex from symbol table
    {
        result = result && entry->Read(&structure->fixedExpIndexCount, alignment);
        structure->fixedExpIndexID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->fixedExpIndex = pointerEntry->ReadArray<FLOAT>(structure->fixedExpIndexCount, alignment);
            result = structure->fixedExpIndex != NULL;
        }
        if (!result || structure->fixedExpIndex == NULL)
        {
            structure->fixedExpIndexCount = 0;
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load LEDMixType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadLEDMixType(
    ParameterFileSymbolTableEntry* entry,
    LEDMixType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->LED1Setting, alignment);
    result = result && entry->Read(&structure->LED2Setting, alignment);
    result = result && entry->Read(&structure->RGRatio, alignment);
    result = result && entry->Read(&structure->BGRatio, alignment);
    result = result && entry->Read(&structure->flux, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load LEDMatchTableType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadLEDMatchTableType(
    ParameterFileSymbolTableEntry* entry,
    LEDMatchTableType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->enableDualLED, alignment);
    result = result && entry->Read(&structure->dualLEDIntersectSlope, alignment);
    result = result && entry->Read(&structure->LEDPowerSize, alignment);
    result = result && entry->Read(&structure->LEDMixSize, alignment);

    // Reading Array CCTTables from symbol table
    {
        result = result && entry->Read(&structure->CCTTablesCount, alignment);
        structure->CCTTablesID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->CCTTables = PARAMETER_NEW LEDMixType[structure->CCTTablesCount];
        }
        if (!result || structure->CCTTables == NULL)
        {
            structure->CCTTablesCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->CCTTablesCount; i++)
        {
            result = LoadLEDMixType(pointerEntry, &structure->CCTTables[i], alignment);
        }
    }
    result = result && LoadLEDMixCalibType(entry, &structure->CCTTableCalibration, alignment);
    result = result && LoadLEDMeasurementType(entry, &structure->LEDMeasConfig, alignment);
    result = result && entry->Read(&structure->enableDerating, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load FlashExtensionType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadFlashExtensionType(
    ParameterFileSymbolTableEntry* entry,
    FlashExtensionType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = aecglobalelements::aecglobalelementsClass::LoadStartEndType(entry, &structure->flashLuxTrigger, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadStartEndType(entry, &structure->flashFDRequestDelayLuxTrigger, alignment);
    result = result && LoadLEDMatchTableType(entry, &structure->LEDTable, alignment);
    result = result && entry->Read(&structure->enableForceAFInLEDOnMode, alignment);
    result = result && LoadLEDInlineCalibType(entry, &structure->LEDInlineCalib, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load FlashArbitrationType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadFlashArbitrationType(
    ParameterFileSymbolTableEntry* entry,
    FlashArbitrationType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->expTableIDPreFlash, alignment);
    result = result && entry->Read(&structure->expTableIDMainFlash, alignment);
    result = result && entry->Read(&structure->expTableIDFlashMeasurement, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load TorchConvType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadTorchConvType(
    ParameterFileSymbolTableEntry* entry,
    TorchConvType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->enableTorchConvergence, alignment);
    result = result && entry->Read(&structure->tolMultUnitStepSize, alignment);
    structure->frameSkipMethod = (aecglobalelements::ConvFrameSkipType)entry->ReadEnum(&result, alignment);
    result = result && entry->Read(&structure->aggressiveness, alignment);
    result = result && entry->Read(&structure->startupAggressiveness, alignment);
    result = result && entry->Read(&structure->ADRCConvSpeed, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load DynamicEnterSkip
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadDynamicEnterSkip(
    ParameterFileSymbolTableEntry* entry,
    DynamicEnterSkip* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->enableDynamicEnterSkip, alignment);
    result = result && entry->Read(&structure->preflashMinFrameSkip, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadStartEndType(entry, &structure->FPSRange, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load PreFlashConvergenceType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadPreFlashConvergenceType(
    ParameterFileSymbolTableEntry* entry,
    PreFlashConvergenceType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    structure->frameSkipMethod = (aecglobalelements::ConvFrameSkipType)entry->ReadEnum(&result, alignment);
    result = result && entry->Read(&structure->aggressiveness, alignment);
    result = result && entry->Read(&structure->settledFrameCountThres, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadSwitchCounterType(entry, &structure->preflashFrameCounterEnter, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadSwitchCounterType(entry, &structure->preflashFrameCounterExit, alignment);
    result = result && LoadDynamicEnterSkip(entry, &structure->dynamicEnterSkip, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load FlashConvergenceType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadFlashConvergenceType(
    ParameterFileSymbolTableEntry* entry,
    FlashConvergenceType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->flashTuningBreak, alignment);
    result = result && LoadPreFlashConvergenceType(entry, &structure->preflashConv, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadRapidConvType(entry, &structure->flashMeasurementConv, alignment);
    result = result && LoadTorchConvType(entry, &structure->torchConv, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load DynamicTrackerDelayType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadDynamicTrackerDelayType(
    ParameterFileSymbolTableEntry* entry,
    DynamicTrackerDelayType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->enableTrackerDynamicDelay, alignment);
    result = result && entry->Read(&structure->minLumaToSkipPreTracker, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load AECTrackerFlashType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadAECTrackerFlashType(
    ParameterFileSymbolTableEntry* entry,
    AECTrackerFlashType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->enableTrackerFlash, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadStartEndType(entry, &structure->ledTrackerWeight, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadStartEndType(entry, &structure->ledTrackerSize, alignment);
    result = result && entry->Read(&structure->TrackerFlashFrameCount, alignment);
    result = result && entry->Read(&structure->TrackerFlashLumaTarget, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadStartEndType(entry, &structure->trackerSizeExpEffect, alignment);
    result = result && entry->Read(&structure->statsUpdateDelayTimeEnter, alignment);
    result = result && entry->Read(&structure->statsUpdateDelayTimeExit, alignment);
    result = result && LoadDynamicTrackerDelayType(entry, &structure->dynamicTrackerDelay, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load DynamicDelayType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadDynamicDelayType(
    ParameterFileSymbolTableEntry* entry,
    DynamicDelayType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->enableFDDynamicDelay, alignment);
    result = result && entry->Read(&structure->minLumaToSkipPreFD, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load AECFaceDetectionFlashType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadAECFaceDetectionFlashType(
    ParameterFileSymbolTableEntry* entry,
    AECFaceDetectionFlashType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->enableFDFlash, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadStartEndType(entry, &structure->ledFaceWeight, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadStartEndType(entry, &structure->ledFaceSize, alignment);
    result = result && entry->Read(&structure->FDFlashFrameCount, alignment);
    result = result && entry->Read(&structure->FDFlashLumaTarget, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadStartEndType(entry, &structure->faceSizeExpEffect, alignment);
    result = result && entry->Read(&structure->statsUpdateDelayTimeEnter, alignment);
    result = result && entry->Read(&structure->statsUpdateDelayTimeExit, alignment);
    result = result && LoadDynamicDelayType(entry, &structure->dynamicDelay, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load FlashDynamicMinAdjType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadFlashDynamicMinAdjType(
    ParameterFileSymbolTableEntry* entry,
    FlashDynamicMinAdjType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->enableDynamicMinAdj, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadStartEndType(entry, &structure->percThresh, alignment);
    result = result && entry->Read(&structure->minLumaAdjEnd, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load FlashStatsPreprocessingType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadFlashStatsPreprocessingType(
    ParameterFileSymbolTableEntry* entry,
    FlashStatsPreprocessingType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->thresBrightLevelDiff, alignment);
    result = result && entry->Read(&structure->thresBrightLevel, alignment);
    result = result && entry->Read(&structure->thresBrightSatDiff, alignment);
    result = result && entry->Read(&structure->thresBrightSat, alignment);
    result = result && entry->Read(&structure->minLuma, alignment);
    result = result && entry->Read(&structure->minLumaAdj, alignment);
    result = result && LoadFlashDynamicMinAdjType(entry, &structure->minLumaAdjDynamic, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load SmartFlashType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadSmartFlashType(
    ParameterFileSymbolTableEntry* entry,
    SmartFlashType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->enableSmartFlashEst, alignment);
    result = result && entry->Read(&structure->smartFlashEstStrength, alignment);
    result = result && entry->Read(&structure->minOffStats, alignment);
    result = result && entry->Read(&structure->kFloorPct, alignment);
    result = result && entry->Read(&structure->satPreventStrength, alignment);
    result = result && entry->Read(&structure->enableSpeckleHandling, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadStartEndType(entry, &structure->speckleSatPctRange, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load FlashLumaTargetType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadFlashLumaTargetType(
    ParameterFileSymbolTableEntry* entry,
    FlashLumaTargetType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->enableFlashTarget, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadLuxLumaTargetType(entry, &structure->flashTarget, alignment);
    result = result && aecglobalelements::aecglobalelementsClass::LoadStartEndType(entry, &structure->flashInfluenceTargetInterpolation, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load FlashMeteringType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadFlashMeteringType(
    ParameterFileSymbolTableEntry* entry,
    FlashMeteringType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadFlashLumaTargetType(entry, &structure->flashLumaTarget, alignment);
    result = result && LoadSmartFlashType(entry, &structure->smartFlash, alignment);
    result = result && LoadFlashStatsPreprocessingType(entry, &structure->statsPreprocessing, alignment);
    result = result && LoadAECFaceDetectionFlashType(entry, &structure->FDFlash, alignment);
    result = result && LoadAECTrackerFlashType(entry, &structure->TrackerFlash, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load AECFlashType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::LoadAECFlashType(
    ParameterFileSymbolTableEntry* entry,
    AECFlashType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = Loadmodule_versionStruct(entry, &structure->module_version, alignment);
    result = result && Loadparameter_versionStruct(entry, &structure->parameter_version, alignment);
    result = result && LoadFlashMeteringType(entry, &structure->flashMtr, alignment);
    result = result && LoadFlashConvergenceType(entry, &structure->flashConv, alignment);
    result = result && LoadFlashArbitrationType(entry, &structure->flashArb, alignment);
    result = result && LoadFlashExtensionType(entry, &structure->flashExt, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load module_versionStruct
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::Loadmodule_versionStruct(
    ParameterFileSymbolTableEntry* entry,
    AECFlashType::module_versionStruct* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->major_revision, alignment);
    result = result && entry->Read(&structure->minor_revision, alignment);
    result = result && entry->Read(&structure->incr_revision, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load parameter_versionStruct
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL AECFlashTypeClass::Loadparameter_versionStruct(
    ParameterFileSymbolTableEntry* entry,
    AECFlashType::parameter_versionStruct* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading String revision from symbol table
    {
        UINT32 count = 0;
        result = entry->Read(&count, alignment);
        ParameterFileSymbolTableEntry* stringPointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && stringPointerEntry != NULL;
        structure->revision = NULL;
        result = result && stringPointerEntry->ReadString(&structure->revision, count, alignment);
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload LEDInlineCalibTargetType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AECFlashTypeClass::UnloadLEDInlineCalibTargetType(
    LEDInlineCalibTargetType* structure)
{
    PARAMETER_DELETE[] structure->LEDInlineCalibTargetZone;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload LEDInlineCalibType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AECFlashTypeClass::UnloadLEDInlineCalibType(
    LEDInlineCalibType* structure)
{
    UnloadLEDInlineCalibTargetType(&structure->LEDInlineCalibTarget);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload LEDMixCalibType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AECFlashTypeClass::UnloadLEDMixCalibType(
    LEDMixCalibType* structure)
{
    PARAMETER_DELETE[] structure->calibEntries;
    PARAMETER_DELETE[] structure->statsRatioOKRange;
    PARAMETER_DELETE[] structure->fixedExpIndex;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload LEDMatchTableType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AECFlashTypeClass::UnloadLEDMatchTableType(
    LEDMatchTableType* structure)
{
    PARAMETER_DELETE[] structure->CCTTables;
    UnloadLEDMixCalibType(&structure->CCTTableCalibration);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload FlashExtensionType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AECFlashTypeClass::UnloadFlashExtensionType(
    FlashExtensionType* structure)
{
    UnloadLEDMatchTableType(&structure->LEDTable);
    UnloadLEDInlineCalibType(&structure->LEDInlineCalib);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload FlashLumaTargetType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AECFlashTypeClass::UnloadFlashLumaTargetType(
    FlashLumaTargetType* structure)
{
    aecglobalelements::aecglobalelementsClass::UnloadLuxLumaTargetType(&structure->flashTarget);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload FlashMeteringType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AECFlashTypeClass::UnloadFlashMeteringType(
    FlashMeteringType* structure)
{
    UnloadFlashLumaTargetType(&structure->flashLumaTarget);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload AECFlashType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AECFlashTypeClass::UnloadAECFlashType(
    AECFlashType* structure)
{
    Unloadparameter_versionStruct(&structure->parameter_version);
    UnloadFlashMeteringType(&structure->flashMtr);
    UnloadFlashExtensionType(&structure->flashExt);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload parameter_versionStruct
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AECFlashTypeClass::Unloadparameter_versionStruct(
    AECFlashType::parameter_versionStruct* structure)
{
    PARAMETER_DELETE[] structure->revision;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Parse symbol table entry, and return a new object
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ParameterModule* AECFlashTypeClass::Parse(
    ParameterFileSymbolTableEntry* entry,
    UINT64 alignment) const
{
    AECFlashTypeClass* cls = NULL;

    if (PARAMETER_STRCMP(Type, entry->Type) == 0 && Version.Value == entry->Version.Value)
    {
        cls = PARAMETER_NEW AECFlashTypeClass(GetName(entry->Type), 
            entry->ModeId, entry->Mode);
        if (cls != NULL)
        {
            BOOL result = TRUE;

            cls->SymbolTableID = entry->ID;
            cls->ID            = entry->ID;

            result = result && LoadAECFlashType(entry, cls, alignment);

            if (!result)
            {
                PARAMETER_DELETE cls;
                cls = NULL;
            }
        }
    }
    return (ParameterModule*)cls;
}


AECFLASH_NAMESPACE_END
