////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2023 Qualcomm Technologies, Inc.
// All Rights Reserved.
// Confidential and Proprietary - Qualcomm Technologies, Inc.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// THIS IS AUTO-GENERATED CODE.  PLEASE DO NOT EDIT (File bug reports against tools).
///
/// Auto-generated by: Parameter Parser V2.0.0 (1907311625)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file  aecglobalelements.h
/// @brief Auto-generated Chromatix parameter file
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef AECGLOBALELEMENTS_H
#define AECGLOBALELEMENTS_H

#include "parametermodule.h"
#include "parameterfilesymboltable.h"
#include "parametertypes.h"
#include "globalelements.h"

#define AECGLOBALELEMENTS_NAMESPACE_BEGIN namespace aecglobalelements {
#define AECGLOBALELEMENTS_NAMESPACE_END }

AECGLOBALELEMENTS_NAMESPACE_BEGIN

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// LuxLumaTargetZoneDataType
/// Comments:       AEC Tuning: Key metering structures
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct LuxLumaTargetZoneDataType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// lumaTarget
    ///
    /// Tuning Level:  often_tune
    /// Description:   Luma target value for each zone with 8 bit range.
    /// Type:          float
    /// Range:         [0,255]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FLOAT lumaTarget;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// TriggerPointType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct TriggerPointType
{
    FLOAT start;
    FLOAT end;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// LuxLumaTargetZoneType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct LuxLumaTargetZoneType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// zoneTrigger
    ///
    /// Description:   lux level start and end values that define trigger region
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    TriggerPointType          zoneTrigger;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// zoneData
    ///
    /// Description:   Triggered data: Luma targets that will be adjusted based on lux level
    /// Comments:       AEC Tuning: Key metering structures
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    LuxLumaTargetZoneDataType zoneData;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// LuxLumaTargetType
///
/// Description:   Luma target tuning structure, which is shared between normal and flash use case.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct LuxLumaTargetType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// luxLumaTargetZone - Array
    /// Min Length:    1
    /// Max Length:    Unbounded
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    UINT32                 luxLumaTargetZoneCount;
    UINT32                 luxLumaTargetZoneID;
    LuxLumaTargetZoneType* luxLumaTargetZone;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// StartEndType
/// Comments:       Base Type Tuning Definition
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct StartEndType
{
    FLOAT start;
    FLOAT end;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// LuxFaceWeightZoneDataType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct LuxFaceWeightZoneDataType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// LuxFaceWeight
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   Min and Max face luma weight wrt face size.
    /// Comments:       Base Type Tuning Definition
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    StartEndType LuxFaceWeight;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// LuxFaceWeightZoneType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct LuxFaceWeightZoneType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// zoneTrigger
    ///
    /// Description:   lux level start and end values that define trigger region
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    TriggerPointType          zoneTrigger;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// zoneData
    ///
    /// Description:   Triggered data: face weight that will be adjusted based on lux level
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    LuxFaceWeightZoneDataType zoneData;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// LuxFaceWeightType
///
/// Description:   Face weight tuning structure, which is shared between normal and flash use case.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct LuxFaceWeightType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// LuxFaceWeightZone - Array
    /// Min Length:    1
    /// Max Length:    Unbounded
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    UINT32                 LuxFaceWeightZoneCount;
    UINT32                 LuxFaceWeightZoneID;
    LuxFaceWeightZoneType* LuxFaceWeightZone;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// LuxTrackerWeightZoneDataType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct LuxTrackerWeightZoneDataType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// LuxTrackerWeight
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   Min and Max tracker luma weight wrt tracker size.
    /// Comments:       Base Type Tuning Definition
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    StartEndType LuxTrackerWeight;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// LuxTrackerWeightZoneType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct LuxTrackerWeightZoneType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// zoneTrigger
    ///
    /// Description:   lux level start and end values that define trigger region
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    TriggerPointType             zoneTrigger;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// zoneData
    ///
    /// Description:   Triggered data: tracker weight that will be adjusted based on lux level
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    LuxTrackerWeightZoneDataType zoneData;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// LuxTrackerWeightType
///
/// Description:   Tracker weight tuning structure, which is shared between normal and flash use case.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct LuxTrackerWeightType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// LuxTrackerWeightZone - Array
    /// Min Length:    1
    /// Max Length:    Unbounded
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    UINT32                    LuxTrackerWeightZoneCount;
    UINT32                    LuxTrackerWeightZoneID;
    LuxTrackerWeightZoneType* LuxTrackerWeightZone;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECIirFltrCfgType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct AECIirFltrCfgType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// enable
    ///
    /// Description:   Flag to enable IIR filter or not.
    /// Type:          int
    /// Range:         [0, 1]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32 enable;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// numOfSamples
    ///
    /// Description:   Length of the IIR filter
    /// Type:          int
    /// Range:         [2,2]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32 numOfSamples;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// coeffNumerator
    ///
    /// Description:   IIR filter coefficient in numerator. An first order IIR filter is designed, the coefficients in numerator
    ///                and denominator are typically required. This parameter defines the coefficient in the numerator.
    /// Type:          float
    /// Range:         [unbounded,unbounded]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FLOAT coeffNumerator;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// coeffDenominator
    ///
    /// Description:   IIR filter coefficient in denominator. An first order IIR filter is designed, the coefficients in
    ///                numerator and denominator are typically required. This parameter defines the coefficient in the
    ///                denominator.
    /// Type:          float
    /// Range:         [unbounded,unbounded]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FLOAT coeffDenominator;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECMvavgFltrCfgType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct AECMvavgFltrCfgType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// enable
    ///
    /// Description:   Flag to enable moving average filter or not.
    /// Type:          int
    /// Range:         [0, 1]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32 enable;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// numOfSamples
    ///
    /// Description:   Length of the moving average filter.
    /// Type:          int
    /// Range:         [0, 10]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32 numOfSamples;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECMedianFltrCfgType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct AECMedianFltrCfgType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// enable
    ///
    /// Description:   Flag to enable median filter or not.
    /// Type:          int
    /// Range:         [0, 1]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32 enable;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// numOfSamples
    ///
    /// Description:   Length of the median filter.
    /// Type:          int
    /// Range:         [0, 10]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32 numOfSamples;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECSensProfileType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct AECSensProfileType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// triggerThreshold
    ///
    /// Description:   Threshold for the value monitor detection. The threshold is defined as the absolute difference between
    ///                metafilter output and reference baseline.
    /// Type:          float
    /// Range:         [0,unbounded]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FLOAT                triggerThreshold;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// consecutiveCountThreshold
    ///
    /// Description:   Counting threshold for the residue is constantly above/below the trigger_threshold. While
    ///                VM_DETECTOR_UNSTABLE is chosen, the counting threshold means the number of counts that residual(absolute
    ///                difference between signal and baseline) is above the threshold. While VM_DETECTOR_STABLE is chosen, the
    ///                counting threshold means the number of counts that residual (absolute difference between signal and
    ///                baseline) is below the threshold.
    /// Type:          int
    /// Range:         [0,unbounded]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32                consecutiveCountThreshold;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// frameToArmed
    ///
    /// Description:   Number of frames for starting the scene change detection.
    /// Type:          int
    /// Range:         [0,unbounded]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32                frameToArmed;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// medianFltrCfg
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    AECMedianFltrCfgType medianFltrCfg;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// mvavgFltrCfg
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    AECMvavgFltrCfgType  mvavgFltrCfg;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// IIRFltrCfg
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    AECIirFltrCfgType    IIRFltrCfg;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECAbsoluteModeCfgType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct AECAbsoluteModeCfgType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// enable
    ///
    /// Description:   While absolute mode is enabled, i.e., enable=1, value monitor will use the the baseline value as a
    ///                reference baseline. While absolute is disabled, i.e., enable=0, value monitor will adaptively update
    ///                reference baseline according to the metafilter output (referring to frame2armed)
    /// Type:          int
    /// Range:         [0,1]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32 enable;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// baseline
    ///
    /// Description:   This parameter is utilized as absolute mode is enabled. While absolute mode is enabled, value monitor
    ///                will use this parameter as reference baseline.
    /// Type:          float
    /// Range:         [unbounded,unbounded]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FLOAT baseline;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECDetectorTypeEnum
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECDetectorTypeEnum
{
    VMDetectorStable   = 0,
    VMDetectorUnstable = 1
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECValueMonitorType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct AECValueMonitorType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// detectionType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    AECDetectorTypeEnum    detectionType;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// absoluteModeCfg
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    AECAbsoluteModeCfgType absoluteModeCfg;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// sensProfileLow
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    AECSensProfileType     sensProfileLow;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// sensProfileMed
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    AECSensProfileType     sensProfileMed;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// sensProfileHigh
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    AECSensProfileType     sensProfileHigh;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// HistTargetAdjustParamType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct HistTargetAdjustParamType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// minTargetAdjRatio
    ///
    /// Tuning Level:  often_tune
    /// Description:   This value overrides the minimal target adjust ratio in normal histogram AEC.
    /// Type:          float
    /// Range:         [0.1,1.0]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FLOAT minTargetAdjRatio;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// maxTargetAdjRatio
    ///
    /// Tuning Level:  often_tune
    /// Description:   This value overrides the maximal target adjust ratio in normal histogram AEC.
    /// Type:          float
    /// Range:         [1.0,2.0]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FLOAT maxTargetAdjRatio;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// darkRefLow
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   This value overrides the darkRefLow in normal histogram AEC.
    /// Type:          float
    /// Range:         [0,50]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FLOAT darkRefLow;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// satRefHigh
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   This value overrides the satRefHigh in normal histogram AEC.
    /// Type:          float
    /// Range:         [100,500]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FLOAT satRefHigh;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ROIHistAdjZoneDataType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ROIHistAdjZoneDataType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// darkLumaRatioRange
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   The ratio between ROI and frame luma to determine if an ROI is dark ROI.
    /// Comments:       Base Type Tuning Definition
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    StartEndType              darkLumaRatioRange;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// darkROIAdjustParams
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    HistTargetAdjustParamType darkROIAdjustParams;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// brightLumaRatioRange
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   The ratio between ROI and frame luma to determine if an ROI is bright ROI.
    /// Comments:       Base Type Tuning Definition
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    StartEndType              brightLumaRatioRange;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// brightROIAdjustParams
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    HistTargetAdjustParamType brightROIAdjustParams;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ROIHistAdjZoneType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ROIHistAdjZoneType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// zoneTrigger
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    TriggerPointType       zoneTrigger;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// zoneData
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ROIHistAdjZoneDataType zoneData;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECExpIncPrioType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECExpIncPrioType
{
    AECExpIncGain    = 0,
    AECExpIncExpTime = 1,
    AECExpIncPrioMax = 2
};
typedef INT32 ExposureTableIDType;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECBayerGridSubsmplType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECBayerGridSubsmplType
{
    Off = 0,
    SW2 = 1,
    SW4 = 2,
    Max = 3
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECColorChannelType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECColorChannelType
{
    AECColorChannelR   = 0,
    AECColorChannelG   = 1,
    AECColorChannelB   = 2,
    AECColorChannelMax = 3
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECConvAlgoType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECConvAlgoType
{
    AECConvSlowConv = 0,
    AECConvFastConv = 1,
    AECConvMaxConv  = 2
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECAntibandingVsFPSMethod
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECAntibandingVsFPSMethod
{
    LegacyAllowFPSToDrop = 0,
    StrictlyEnforceFPS   = 1,
    MaximizeExposureTime = 2
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ConvFrameSkipType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class ConvFrameSkipType
{
    SmoothNoSkip      = 0,
    SkipOne           = 1,
    SkipSystemLatency = 2
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECStatsHistogramType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECStatsHistogramType
{
    HistogramHDRBHIST = 0,
    HistogramBHIST    = 1,
    HistogramIHIST    = 2
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECStatsHistogramChannelType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECStatsHistogramChannelType
{
    ChannelR    = 0,
    ChannelGr   = 1,
    ChannelGb   = 2,
    ChannelG    = 3,
    ChannelB    = 4,
    ChannelY    = 5,
    ChannelCb   = 6,
    ChannelCr   = 7,
    ChannelRGrB = 8,
    ChannelRGbB = 9
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECStatsSiteSelection
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECStatsSiteSelection
{
    BeforeHDRFusion = 0,
    BeforeDemosaic  = 1,
    BeforeGammaLUT  = 2,
    AfterGammaLUT   = 3
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECStatsPixelExpSelect
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECStatsPixelExpSelect
{
    AllPixels   = 0,
    LongPixels  = 1,
    ShortPixels = 2
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECStatsHistogramUniformityType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECStatsHistogramUniformityType
{
    Even   = 0,
    Uneven = 1
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// HistogramTargetEVMethodType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class HistogramTargetEVMethodType
{
    Legacy      = 0,
    Compensated = 1,
    Freeze      = 2,
    Advanced1   = 3,
    Advanced2   = 4
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECMtrAndExpoConfigType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECMtrAndExpoConfigType
{
    MtrIndepExpIndep   = 0,
    MtrIndepExpFollow  = 1,
    MtrMixExpIndep     = 2,
    MtrIndepExpDynamic = 3
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECDualCamSlaveLuxType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECDualCamSlaveLuxType
{
    Independent      = 0,
    UseMaster        = 1,
    UseSensAdjMaster = 2
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECMultiCamMixingType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECMultiCamMixingType
{
    Static  = 0,
    Dynamic = 1
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECDepthLUTType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECDepthLUTType
{
    DepthLUTDistance   = 0,
    DepthLUTDepth      = 1,
    DepthLUTConfidence = 2,
    DepthLUTReserved1  = 3,
    DepthLUTReserved2  = 4
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECSwitchCounterEnumType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECSwitchCounterEnumType
{
    SwitchCounterSystemDelay   = 0,
    SwitchCounterDisable       = 1,
    SwitchCounterCustomInteger = 2,
    SwitchCounterAdvanced1     = 3,
    SwitchCounterAdvanced2     = 4
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECGyroExpCtrlTriggerDataType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECGyroExpCtrlTriggerDataType
{
    GyroExpCtrlTriggerDataTargetExpoTime = 0,
    GyroExpCtrlTriggerDataAdjRatio       = 1
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AECGyroExpCtrlKeyLevelZoneType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum class AECGyroExpCtrlKeyLevelZoneType
{
    GyroExpCtrlKeyCurExpTimeType = 0,
    GyroExpCtrlKeyLuxIndexType   = 1
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FirstFrameBiasType
///
/// Description:   Heuristics to speed up convergence in first frame
/// Comments:       Rapid Startup is used by both Startup and Flash algorithms
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct FirstFrameBiasType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// enableStartUpBias
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   Enable biasing to converge faster in the first frame in the presence of saturated regions
    /// Type:          bool
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    BOOL         enableStartUpBias;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// firstFrameStepSizeDarkMax
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   When converging from dark to bright: maximum absolute exposure index step size for first frame
    /// Type:          float
    /// Range:         [0,200]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FLOAT        firstFrameStepSizeDarkMax;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// stepSizeBrightAdjRange
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   When converging from bright to dark: Exposure index step size range within which a factor will be applied
    ///                to converge faster in the first frame
    /// Range:         [20,80]
    /// Comments:       Base Type Tuning Definition
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    StartEndType stepSizeBrightAdjRange;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// maxAdjFactor
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   Max factor to boost exposure adjustment in the first frame
    /// Type:          float
    /// Range:         [1.5,3.0]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FLOAT        maxAdjFactor;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// RapidConvType
///
/// Description:   Tuning settings for initial convergence algorithms: FastAEC and AggressiveAEC
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct RapidConvType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// firstFrameBias
    ///
    /// Description:   Heuristics to speed up convergence in first frame
    /// Comments:       Rapid Startup is used by both Startup and Flash algorithms
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FirstFrameBiasType firstFrameBias;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// startExpIndex
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   Preferred initial exposure index
    /// Type:          float
    /// Range:         [0,500]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FLOAT              startExpIndex;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// tolMultUnitStepSize
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   Tolerance expressed as a multiple of unitStepSize
    /// Type:          int
    /// Range:         [1,100]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32              tolMultUnitStepSize;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// frameSkipInit
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   Initial frame skip
    /// Type:          int
    /// Range:         [0,100]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32              frameSkipInit;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// frameSkip
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   How many frames to skip between two adjustments. Depends on sensor sync
    /// Type:          int
    /// Range:         [0,10]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32              frameSkip;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// minSettledCount
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   How many frames without any adjustments before declaring the algorithm is settled
    /// Type:          int
    /// Range:         [0,100]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32              minSettledCount;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// maxFrameConvTimeOut
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   Maximum duration of convergence, in frames
    /// Type:          int
    /// Range:         [1,100]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32              maxFrameConvTimeOut;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// SwitchCounterType
///
/// Description:   Flash measurement configuration. These parameters apply to both flash tuning and flash calibration
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct SwitchCounterType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// type
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   Type of frame counter delay
    /// Default Value: SwitchCounterSystemDelay
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    AECSwitchCounterEnumType type;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// customInteger
    ///
    /// Tuning Level:  rarely_tune
    /// Description:   custom frame count delay
    /// Range:         [0,100]
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32                    customInteger;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ModuleVersionType
///
/// Description:   define major, minor, incremental revision -
/// Comments:       Global Tuning Definition
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ModuleVersionType
{

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// major_revision
    ///
    /// Description:   Major revision number
    /// Type:          int
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32 major_revision;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// minor_revision
    ///
    /// Description:   Minor revision number
    /// Type:          int
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32 minor_revision;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// incr_revision
    ///
    /// Description:   Incremental revision number
    /// Type:          int
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    INT32 incr_revision;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// aecglobalelementsClass
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class aecglobalelementsClass
{
public:

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load LuxLumaTargetZoneDataType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadLuxLumaTargetZoneDataType(
        ParameterFileSymbolTableEntry* entry,
        LuxLumaTargetZoneDataType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load TriggerPointType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadTriggerPointType(
        ParameterFileSymbolTableEntry* entry,
        TriggerPointType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load LuxLumaTargetZoneType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadLuxLumaTargetZoneType(
        ParameterFileSymbolTableEntry* entry,
        LuxLumaTargetZoneType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load LuxLumaTargetType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadLuxLumaTargetType(
        ParameterFileSymbolTableEntry* entry,
        LuxLumaTargetType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load StartEndType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadStartEndType(
        ParameterFileSymbolTableEntry* entry,
        StartEndType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load LuxFaceWeightZoneDataType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadLuxFaceWeightZoneDataType(
        ParameterFileSymbolTableEntry* entry,
        LuxFaceWeightZoneDataType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load LuxFaceWeightZoneType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadLuxFaceWeightZoneType(
        ParameterFileSymbolTableEntry* entry,
        LuxFaceWeightZoneType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load LuxFaceWeightType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadLuxFaceWeightType(
        ParameterFileSymbolTableEntry* entry,
        LuxFaceWeightType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load LuxTrackerWeightZoneDataType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadLuxTrackerWeightZoneDataType(
        ParameterFileSymbolTableEntry* entry,
        LuxTrackerWeightZoneDataType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load LuxTrackerWeightZoneType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadLuxTrackerWeightZoneType(
        ParameterFileSymbolTableEntry* entry,
        LuxTrackerWeightZoneType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load LuxTrackerWeightType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadLuxTrackerWeightType(
        ParameterFileSymbolTableEntry* entry,
        LuxTrackerWeightType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load AECIirFltrCfgType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadAECIirFltrCfgType(
        ParameterFileSymbolTableEntry* entry,
        AECIirFltrCfgType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load AECMvavgFltrCfgType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadAECMvavgFltrCfgType(
        ParameterFileSymbolTableEntry* entry,
        AECMvavgFltrCfgType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load AECMedianFltrCfgType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadAECMedianFltrCfgType(
        ParameterFileSymbolTableEntry* entry,
        AECMedianFltrCfgType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load AECSensProfileType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadAECSensProfileType(
        ParameterFileSymbolTableEntry* entry,
        AECSensProfileType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load AECAbsoluteModeCfgType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadAECAbsoluteModeCfgType(
        ParameterFileSymbolTableEntry* entry,
        AECAbsoluteModeCfgType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load AECValueMonitorType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadAECValueMonitorType(
        ParameterFileSymbolTableEntry* entry,
        AECValueMonitorType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load HistTargetAdjustParamType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadHistTargetAdjustParamType(
        ParameterFileSymbolTableEntry* entry,
        HistTargetAdjustParamType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load ROIHistAdjZoneDataType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadROIHistAdjZoneDataType(
        ParameterFileSymbolTableEntry* entry,
        ROIHistAdjZoneDataType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load ROIHistAdjZoneType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadROIHistAdjZoneType(
        ParameterFileSymbolTableEntry* entry,
        ROIHistAdjZoneType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load FirstFrameBiasType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadFirstFrameBiasType(
        ParameterFileSymbolTableEntry* entry,
        FirstFrameBiasType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load RapidConvType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadRapidConvType(
        ParameterFileSymbolTableEntry* entry,
        RapidConvType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load SwitchCounterType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadSwitchCounterType(
        ParameterFileSymbolTableEntry* entry,
        SwitchCounterType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Load ModuleVersionType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static BOOL LoadModuleVersionType(
        ParameterFileSymbolTableEntry* entry,
        ModuleVersionType* structure,
        UINT64 alignment);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Unload LuxLumaTargetType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static void UnloadLuxLumaTargetType(
        LuxLumaTargetType* structure);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Unload LuxFaceWeightType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static void UnloadLuxFaceWeightType(
        LuxFaceWeightType* structure);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Unload LuxTrackerWeightType
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static void UnloadLuxTrackerWeightType(
        LuxTrackerWeightType* structure);

}; // End class aecglobalelementsClass

AECGLOBALELEMENTS_NAMESPACE_END
#endif // AECGLOBALELEMENTS_H

