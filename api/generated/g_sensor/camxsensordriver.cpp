////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2023 Qualcomm Technologies, Inc.
// All Rights Reserved.
// Confidential and Proprietary - Qualcomm Technologies, Inc.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// THIS IS AUTO-GENERATED CODE.  PLEASE DO NOT EDIT (File bug reports against tools).
///
/// Auto-generated by: Parameter Parser V2.0.0 (1907311625)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file  camxsensordriver.cpp
/// @brief Auto-generated Chromatix parameter file
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "camxsensordriver.h"
#include "parametersetmanager.h"

CAMX_NAMESPACE_BEGIN

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Default Constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SensorDriverDataClass::SensorDriverDataClass(
    const CHAR* name)
    : ParameterModule(name, VersionUnion(MAJOR, MINOR, PATCH), 0, ModeUnion(0))
{
    PARAMETER_INITIALIZE(SymbolTableID);
    PARAMETER_INITIALIZE(module_version);
    PARAMETER_INITIALIZE(slaveInfo);
    PARAMETER_INITIALIZE(regAddrInfo);
    PARAMETER_INITIALIZE(resolutionInfoCount);
    PARAMETER_INITIALIZE(resolutionInfoID);
    PARAMETER_INITIALIZE(resolutionInfo);
    PARAMETER_INITIALIZE(exposureControlInfo);
    PARAMETER_INITIALIZE(streamOnSettings);
    PARAMETER_INITIALIZE(streamOffSettings);
    PARAMETER_INITIALIZE(groupHoldOnSettings);
    PARAMETER_INITIALIZE(groupHoldOffSettings);
    PARAMETER_INITIALIZE(masterSettingsExists);
    PARAMETER_INITIALIZE(masterSettingsID);
    PARAMETER_INITIALIZE(masterSettings);
    PARAMETER_INITIALIZE(slaveSettingsExists);
    PARAMETER_INITIALIZE(slaveSettingsID);
    PARAMETER_INITIALIZE(slaveSettings);
    PARAMETER_INITIALIZE(initSettingsCount);
    PARAMETER_INITIALIZE(initSettingsID);
    PARAMETER_INITIALIZE(initSettings);
    PARAMETER_INITIALIZE(testPatternInfo);
    PARAMETER_INITIALIZE(gmslInfoExists);
    PARAMETER_INITIALIZE(gmslInfoID);
    PARAMETER_INITIALIZE(gmslInfo);
    PARAMETER_INITIALIZE(TemperatureInfoExists);
    PARAMETER_INITIALIZE(TemperatureInfoID);
    PARAMETER_INITIALIZE(TemperatureInfo);
    PARAMETER_INITIALIZE(colorLevelInfo);
    PARAMETER_INITIALIZE(opticalBlackRegionInfo);
    PARAMETER_INITIALIZE(pixelArrayInfo);
    PARAMETER_INITIALIZE(delayInfo);
    PARAMETER_INITIALIZE(sensorProperty);
    PARAMETER_INITIALIZE(noiseCoefficentExists);
    PARAMETER_INITIALIZE(noiseCoefficentID);
    PARAMETER_INITIALIZE(noiseCoefficent);
    PARAMETER_INITIALIZE(noiseCoefficientBayerExists);
    PARAMETER_INITIALIZE(noiseCoefficientBayerID);
    PARAMETER_INITIALIZE(noiseCoefficientBayer);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SensorDriverDataClass::SensorDriverDataClass(
    const CHAR* name,
    UINT32      modeId,
    ModeUnion   mode)
    : ParameterModule(name, VersionUnion(MAJOR, MINOR, PATCH), modeId, mode)
{
    PARAMETER_INITIALIZE(SymbolTableID);
    PARAMETER_INITIALIZE(module_version);
    PARAMETER_INITIALIZE(slaveInfo);
    PARAMETER_INITIALIZE(regAddrInfo);
    PARAMETER_INITIALIZE(resolutionInfo);
    PARAMETER_INITIALIZE(exposureControlInfo);
    PARAMETER_INITIALIZE(streamOnSettings);
    PARAMETER_INITIALIZE(streamOffSettings);
    PARAMETER_INITIALIZE(groupHoldOnSettings);
    PARAMETER_INITIALIZE(groupHoldOffSettings);
    PARAMETER_INITIALIZE(masterSettings);
    PARAMETER_INITIALIZE(slaveSettings);
    PARAMETER_INITIALIZE(initSettings);
    PARAMETER_INITIALIZE(testPatternInfo);
    PARAMETER_INITIALIZE(gmslInfo);
    PARAMETER_INITIALIZE(TemperatureInfo);
    PARAMETER_INITIALIZE(colorLevelInfo);
    PARAMETER_INITIALIZE(opticalBlackRegionInfo);
    PARAMETER_INITIALIZE(pixelArrayInfo);
    PARAMETER_INITIALIZE(delayInfo);
    PARAMETER_INITIALIZE(sensorProperty);
    PARAMETER_INITIALIZE(noiseCoefficent);
    PARAMETER_INITIALIZE(noiseCoefficientBayer);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Destructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SensorDriverDataClass::~SensorDriverDataClass()
{
    UnloadSensorDriverData(this);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GetName
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const CHAR* SensorDriverDataClass::GetName(
    const CHAR* type)
{
    const CHAR* name = type;
    CHAR temp[ParameterFileSymbolTableEntry::TYPE_LEN + 1];
    if (PARAMETER_STRCMP(type, ParameterFileSymbolTableEntry::GetType(temp, "sensorDriverData")) == 0)
    {
        name = "sensorDriverData";
    }
    return name;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load SlaveInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadSlaveInformation(
    ParameterFileSymbolTableEntry* entry,
    SlaveInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading String sensorName from symbol table
    {
        UINT32 count = 0;
        result = entry->Read(&count, alignment);
        ParameterFileSymbolTableEntry* stringPointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && stringPointerEntry != NULL;
        structure->sensorName = NULL;
        result = result && stringPointerEntry->ReadString(&structure->sensorName, count, alignment);
    }
    result = result && entry->Read(&structure->slaveAddress, alignment);
    result = result && entry->Read(&structure->regAddrType, alignment);
    result = result && entry->Read(&structure->regDataType, alignment);
    result = result && entry->Read(&structure->sensorIdRegAddr, alignment);
    result = result && entry->Read(&structure->sensorId, alignment);
    result = result && entry->Read(&structure->sensorIdMask, alignment);
    structure->i2cFrequencyMode = (I2CFrequencyMode)entry->ReadEnum(&result, alignment);
    result = result && camxsensorcommonClass::LoadPowerSequenceInfo(entry, &structure->powerUpSequence, alignment);
    result = result && camxsensorcommonClass::LoadPowerSequenceInfo(entry, &structure->powerDownSequence, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load RegAddrInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadRegAddrInformation(
    ParameterFileSymbolTableEntry* entry,
    RegAddrInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->xOutput, alignment);
    result = result && entry->Read(&structure->yOutput, alignment);
    result = result && entry->Read(&structure->frameLengthLines, alignment);
    result = result && entry->Read(&structure->lineLengthPixelClock, alignment);
    result = result && entry->Read(&structure->coarseIntgTimeAddr, alignment);

    // Reading Optional parameter shortCoarseIntgTimeAddr from symbol table
    {
        result = result && entry->Read(&structure->shortCoarseIntgTimeAddrExists, alignment);
        structure->shortCoarseIntgTimeAddrID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->shortCoarseIntgTimeAddrExists)
        {
            result = result && pointerEntry->Read(&structure->shortCoarseIntgTimeAddr, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->shortCoarseIntgTimeAddr);
        }
    }
    result = result && entry->Read(&structure->globalGainAddr, alignment);

    // Reading Optional parameter shortGlobalGainAddr from symbol table
    {
        result = result && entry->Read(&structure->shortGlobalGainAddrExists, alignment);
        structure->shortGlobalGainAddrID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->shortGlobalGainAddrExists)
        {
            result = result && pointerEntry->Read(&structure->shortGlobalGainAddr, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->shortGlobalGainAddr);
        }
    }

    // Reading Optional parameter digitalGlobalGainAddr from symbol table
    {
        result = result && entry->Read(&structure->digitalGlobalGainAddrExists, alignment);
        structure->digitalGlobalGainAddrID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->digitalGlobalGainAddrExists)
        {
            result = result && pointerEntry->Read(&structure->digitalGlobalGainAddr, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->digitalGlobalGainAddr);
        }
    }

    // Reading Optional parameter digitalGainRedAddr from symbol table
    {
        result = result && entry->Read(&structure->digitalGainRedAddrExists, alignment);
        structure->digitalGainRedAddrID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->digitalGainRedAddrExists)
        {
            result = result && pointerEntry->Read(&structure->digitalGainRedAddr, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->digitalGainRedAddr);
        }
    }

    // Reading Optional parameter digitalGainGreenRedAddr from symbol table
    {
        result = result && entry->Read(&structure->digitalGainGreenRedAddrExists, alignment);
        structure->digitalGainGreenRedAddrID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->digitalGainGreenRedAddrExists)
        {
            result = result && pointerEntry->Read(&structure->digitalGainGreenRedAddr, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->digitalGainGreenRedAddr);
        }
    }

    // Reading Optional parameter digitalGainBlueAddr from symbol table
    {
        result = result && entry->Read(&structure->digitalGainBlueAddrExists, alignment);
        structure->digitalGainBlueAddrID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->digitalGainBlueAddrExists)
        {
            result = result && pointerEntry->Read(&structure->digitalGainBlueAddr, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->digitalGainBlueAddr);
        }
    }

    // Reading Optional parameter digitalGainGreenBlueAddr from symbol table
    {
        result = result && entry->Read(&structure->digitalGainGreenBlueAddrExists, alignment);
        structure->digitalGainGreenBlueAddrID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->digitalGainGreenBlueAddrExists)
        {
            result = result && pointerEntry->Read(&structure->digitalGainGreenBlueAddr, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->digitalGainGreenBlueAddr);
        }
    }
    result = result && entry->Read(&structure->testPatternRAddr, alignment);
    result = result && entry->Read(&structure->testPatternGRAddr, alignment);
    result = result && entry->Read(&structure->testPatternBAddr, alignment);
    result = result && entry->Read(&structure->testPatternGBAddr, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load IntegrationInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadIntegrationInfo(
    ParameterFileSymbolTableEntry* entry,
    IntegrationInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->integrationTimeMin, alignment);
    result = result && entry->Read(&structure->integrationTimeStep, alignment);
    result = result && entry->Read(&structure->integrationTimeMargin, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load StreamConfiguration
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadStreamConfiguration(
    ParameterFileSymbolTableEntry* entry,
    StreamConfiguration* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->vc, alignment);
    result = result && entry->Read(&structure->dt, alignment);
    result = result && camxsensorcommonClass::LoadFrameDimension(entry, &structure->frameDimension, alignment);
    result = result && entry->Read(&structure->bitWidth, alignment);
    structure->type = (StreamType)entry->ReadEnum(&result, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load StreamInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadStreamInformation(
    ParameterFileSymbolTableEntry* entry,
    StreamInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading Array streamConfiguration from symbol table
    {
        result = entry->Read(&structure->streamConfigurationCount, alignment);
        structure->streamConfigurationID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->streamConfiguration = PARAMETER_NEW StreamConfiguration[structure->streamConfigurationCount];
        }
        if (!result || structure->streamConfiguration == NULL)
        {
            structure->streamConfigurationCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->streamConfigurationCount; i++)
        {
            result = LoadStreamConfiguration(pointerEntry, &structure->streamConfiguration[i], alignment);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load BorderInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadBorderInformation(
    ParameterFileSymbolTableEntry* entry,
    BorderInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->left, alignment);
    result = result && entry->Read(&structure->right, alignment);
    result = result && entry->Read(&structure->top, alignment);
    result = result && entry->Read(&structure->bottom, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load HDR3ExposureInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadHDR3ExposureInformation(
    ParameterFileSymbolTableEntry* entry,
    HDR3ExposureInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading Optional parameter HDR3ExposureType from symbol table
    {
        result = entry->Read(&structure->HDR3ExposureTypeExists, alignment);
        structure->HDR3ExposureTypeID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->HDR3ExposureTypeExists)
        {
            structure->HDR3ExposureType = (HDR3ExposureTypeInfo)pointerEntry->ReadEnum(&result, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->HDR3ExposureType);
        }
    }

    // Reading Optional parameter sensorLTCRatioAddr from symbol table
    {
        result = result && entry->Read(&structure->sensorLTCRatioAddrExists, alignment);
        structure->sensorLTCRatioAddrID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->sensorLTCRatioAddrExists)
        {
            result = result && pointerEntry->Read(&structure->sensorLTCRatioAddr, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->sensorLTCRatioAddr);
        }
    }

    // Reading Optional parameter numberOfLTCRatioRegCount from symbol table
    {
        result = result && entry->Read(&structure->numberOfLTCRatioRegCountExists, alignment);
        structure->numberOfLTCRatioRegCountID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->numberOfLTCRatioRegCountExists)
        {
            result = result && pointerEntry->Read(&structure->numberOfLTCRatioRegCount, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->numberOfLTCRatioRegCount);
        }
    }

    // Reading Optional parameter InSensorHDR3ExpLineLengthPixelClock from symbol table
    {
        result = result && entry->Read(&structure->InSensorHDR3ExpLineLengthPixelClockExists, alignment);
        structure->InSensorHDR3ExpLineLengthPixelClockID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->InSensorHDR3ExpLineLengthPixelClockExists)
        {
            result = result && pointerEntry->Read(&structure->InSensorHDR3ExpLineLengthPixelClock, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->InSensorHDR3ExpLineLengthPixelClock);
        }
    }

    // Reading Optional parameter InSensorHDR3ExpFrameLengthLines from symbol table
    {
        result = result && entry->Read(&structure->InSensorHDR3ExpFrameLengthLinesExists, alignment);
        structure->InSensorHDR3ExpFrameLengthLinesID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->InSensorHDR3ExpFrameLengthLinesExists)
        {
            result = result && pointerEntry->Read(&structure->InSensorHDR3ExpFrameLengthLines, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->InSensorHDR3ExpFrameLengthLines);
        }
    }

    // Reading Optional parameter InSensorHDR3ExpMaxAnalogGain from symbol table
    {
        result = result && entry->Read(&structure->InSensorHDR3ExpMaxAnalogGainExists, alignment);
        structure->InSensorHDR3ExpMaxAnalogGainID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->InSensorHDR3ExpMaxAnalogGainExists)
        {
            result = result && pointerEntry->Read(&structure->InSensorHDR3ExpMaxAnalogGain, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->InSensorHDR3ExpMaxAnalogGain);
        }
    }

    // Reading Optional parameter InSensorHDR3ExpStartSettings from symbol table
    {
        result = result && entry->Read(&structure->InSensorHDR3ExpStartSettingsExists, alignment);
        structure->InSensorHDR3ExpStartSettingsID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->InSensorHDR3ExpStartSettingsExists)
        {
            result = result && camxsensorcommonClass::LoadSettingsInfo(pointerEntry, &structure->InSensorHDR3ExpStartSettings, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->InSensorHDR3ExpStartSettings);
        }
    }

    // Reading Optional parameter InSensorHDR3ExpStopSettings from symbol table
    {
        result = result && entry->Read(&structure->InSensorHDR3ExpStopSettingsExists, alignment);
        structure->InSensorHDR3ExpStopSettingsID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->InSensorHDR3ExpStopSettingsExists)
        {
            result = result && camxsensorcommonClass::LoadSettingsInfo(pointerEntry, &structure->InSensorHDR3ExpStopSettings, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->InSensorHDR3ExpStopSettings);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ZZHDRInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadZZHDRInformation(
    ParameterFileSymbolTableEntry* entry,
    ZZHDRInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading Optional parameter ZZHDRPattern from symbol table
    {
        result = entry->Read(&structure->ZZHDRPatternExists, alignment);
        structure->ZZHDRPatternID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->ZZHDRPatternExists)
        {
            structure->ZZHDRPattern = (ZZHDRColorPattern)pointerEntry->ReadEnum(&result, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->ZZHDRPattern);
        }
    }

    // Reading Optional parameter ZZHDRFirstExposure from symbol table
    {
        result = result && entry->Read(&structure->ZZHDRFirstExposureExists, alignment);
        structure->ZZHDRFirstExposureID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->ZZHDRFirstExposureExists)
        {
            structure->ZZHDRFirstExposure = (ZZHDRFirstExposurePattern)pointerEntry->ReadEnum(&result, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->ZZHDRFirstExposure);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ResolutionData
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadResolutionData(
    ParameterFileSymbolTableEntry* entry,
    ResolutionData* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    structure->colorFilterArrangement = (ColorFilterArrangement)entry->ReadEnum(&result, alignment);
    result = result && LoadStreamInformation(entry, &structure->streamInfo, alignment);
    result = result && entry->Read(&structure->lineLengthPixelClock, alignment);
    result = result && entry->Read(&structure->frameLengthLines, alignment);
    result = result && entry->Read(&structure->minHorizontalBlanking, alignment);
    result = result && entry->Read(&structure->minVerticalBlanking, alignment);
    result = result && entry->Read(&structure->outputPixelClock, alignment);
    result = result && entry->Read(&structure->horizontalBinning, alignment);
    result = result && entry->Read(&structure->verticalBinning, alignment);
    result = result && entry->Read(&structure->frameRate, alignment);
    result = result && entry->Read(&structure->laneCount, alignment);

    // Reading Optional parameter downScaleFactor from symbol table
    {
        result = result && entry->Read(&structure->downScaleFactorExists, alignment);
        structure->downScaleFactorID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->downScaleFactorExists)
        {
            result = result && pointerEntry->Read(&structure->downScaleFactor, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->downScaleFactor);
        }
    }
    result = result && entry->Read(&structure->settleTimeNs, alignment);
    result = result && entry->Read(&structure->is3Phase, alignment);

    // Reading Optional parameter integrationInfo from symbol table
    {
        result = result && entry->Read(&structure->integrationInfoExists, alignment);
        structure->integrationInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->integrationInfoExists)
        {
            result = result && LoadIntegrationInfo(pointerEntry, &structure->integrationInfo, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->integrationInfo);
        }
    }
    result = result && camxsensorcommonClass::LoadSettingsInfo(entry, &structure->resSettings, alignment);
    result = result && LoadBorderInformation(entry, &structure->cropInfo, alignment);

    // Reading Optional parameter ZZHDRInfo from symbol table
    {
        result = result && entry->Read(&structure->ZZHDRInfoExists, alignment);
        structure->ZZHDRInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->ZZHDRInfoExists)
        {
            result = result && LoadZZHDRInformation(pointerEntry, &structure->ZZHDRInfo, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->ZZHDRInfo);
        }
    }

    // Reading Optional parameter HDR3ExposureInfo from symbol table
    {
        result = result && entry->Read(&structure->HDR3ExposureInfoExists, alignment);
        structure->HDR3ExposureInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->HDR3ExposureInfoExists)
        {
            result = result && LoadHDR3ExposureInformation(pointerEntry, &structure->HDR3ExposureInfo, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->HDR3ExposureInfo);
        }
    }

    // Reading Optional parameter RemosaicTypeInfo from symbol table
    {
        result = result && entry->Read(&structure->RemosaicTypeInfoExists, alignment);
        structure->RemosaicTypeInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->RemosaicTypeInfoExists)
        {
            structure->RemosaicTypeInfo = (RemosaicType)pointerEntry->ReadEnum(&result, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->RemosaicTypeInfo);
        }
    }

    // Reading Array capability from symbol table
    {
        result = result && entry->Read(&structure->capabilityCount, alignment);
        structure->capabilityID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->capability = PARAMETER_NEW SensorCapability[structure->capabilityCount];
        }
        if (!result || structure->capability == NULL)
        {
            structure->capabilityCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->capabilityCount; i++)
        {
            structure->capability[i] = (SensorCapability)pointerEntry->ReadEnum(&result, alignment);
        }
    }

    // Reading Optional parameter ADCReadoutTime from symbol table
    {
        result = result && entry->Read(&structure->ADCReadoutTimeExists, alignment);
        structure->ADCReadoutTimeID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->ADCReadoutTimeExists)
        {
            result = result && pointerEntry->Read(&structure->ADCReadoutTime, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->ADCReadoutTime);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ResolutionInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadResolutionInformation(
    ParameterFileSymbolTableEntry* entry,
    ResolutionInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading Optional parameter sensorVersion from symbol table
    {
        result = entry->Read(&structure->sensorVersionExists, alignment);
        structure->sensorVersionID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->sensorVersionExists)
        {
            result = pointerEntry->Read(&structure->sensorVersion, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->sensorVersion);
        }
    }

    // Reading Array resolutionData from symbol table
    {
        result = result && entry->Read(&structure->resolutionDataCount, alignment);
        structure->resolutionDataID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->resolutionData = PARAMETER_NEW ResolutionData[structure->resolutionDataCount];
        }
        if (!result || structure->resolutionData == NULL)
        {
            structure->resolutionDataCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->resolutionDataCount; i++)
        {
            result = LoadResolutionData(pointerEntry, &structure->resolutionData[i], alignment);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load InitSettings
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadInitSettings(
    ParameterFileSymbolTableEntry* entry,
    InitSettings* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->sensorVersion, alignment);
    result = result && camxsensorcommonClass::LoadSettingsInfo(entry, &structure->initSetting, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ExposureContorlInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadExposureContorlInformation(
    ParameterFileSymbolTableEntry* entry,
    ExposureContorlInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->maxAnalogGain, alignment);
    result = result && entry->Read(&structure->maxDigitalGain, alignment);

    // Reading Optional parameter minAnalogGain from symbol table
    {
        result = result && entry->Read(&structure->minAnalogGainExists, alignment);
        structure->minAnalogGainID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->minAnalogGainExists)
        {
            result = result && pointerEntry->Read(&structure->minAnalogGain, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->minAnalogGain);
        }
    }
    result = result && entry->Read(&structure->verticalOffset, alignment);

    // Reading Optional parameter multiCamLineDelta from symbol table
    {
        result = result && entry->Read(&structure->multiCamLineDeltaExists, alignment);
        structure->multiCamLineDeltaID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->multiCamLineDeltaExists)
        {
            result = result && pointerEntry->Read(&structure->multiCamLineDelta, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->multiCamLineDelta);
        }
    }
    result = result && entry->Read(&structure->maxLineCount, alignment);

    // Reading Optional parameter minLineCount from symbol table
    {
        result = result && entry->Read(&structure->minLineCountExists, alignment);
        structure->minLineCountID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->minLineCountExists)
        {
            result = result && pointerEntry->Read(&structure->minLineCount, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->minLineCount);
        }
    }
    result = result && entry->Read(&structure->realToRegDigitalGainConversionFactor, alignment);

    // Reading String realToRegGain from symbol table
    {
        UINT32 count = 0;
        result = result && entry->Read(&count, alignment);
        ParameterFileSymbolTableEntry* stringPointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && stringPointerEntry != NULL;
        structure->realToRegGain = NULL;
        result = result && stringPointerEntry->ReadString(&structure->realToRegGain, count, alignment);
    }

    // Reading String regToRealGain from symbol table
    {
        UINT32 count = 0;
        result = result && entry->Read(&count, alignment);
        ParameterFileSymbolTableEntry* stringPointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && stringPointerEntry != NULL;
        structure->regToRealGain = NULL;
        result = result && stringPointerEntry->ReadString(&structure->regToRealGain, count, alignment);
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load TestPatternData
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadTestPatternData(
    ParameterFileSymbolTableEntry* entry,
    TestPatternData* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    structure->mode = (TestPatternMode)entry->ReadEnum(&result, alignment);
    result = result && camxsensorcommonClass::LoadSettingsInfo(entry, &structure->settings, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load TestPatternInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadTestPatternInformation(
    ParameterFileSymbolTableEntry* entry,
    TestPatternInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading Array testPatternData from symbol table
    {
        result = entry->Read(&structure->testPatternDataCount, alignment);
        structure->testPatternDataID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->testPatternData = PARAMETER_NEW TestPatternData[structure->testPatternDataCount];
        }
        if (!result || structure->testPatternData == NULL)
        {
            structure->testPatternDataCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->testPatternDataCount; i++)
        {
            result = LoadTestPatternData(pointerEntry, &structure->testPatternData[i], alignment);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load GmslAliasInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadGmslAliasInfo(
    ParameterFileSymbolTableEntry* entry,
    GmslAliasInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->sensorVersion, alignment);
    result = result && entry->Read(&structure->aliasAddr, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load GmslSettings
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadGmslSettings(
    ParameterFileSymbolTableEntry* entry,
    GmslSettings* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->sensorVersion, alignment);
    result = result && camxsensorcommonClass::LoadSettingsInfo(entry, &structure->gmslSetting, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load GmslInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadGmslInformation(
    ParameterFileSymbolTableEntry* entry,
    GmslInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->isGmslModule, alignment);
    result = result && entry->Read(&structure->dualGmslVersion, alignment);
    result = result && entry->Read(&structure->desSlaveAddr, alignment);
    result = result && entry->Read(&structure->desRevAddr, alignment);
    result = result && entry->Read(&structure->desChipIdAddr, alignment);
    result = result && entry->Read(&structure->serSlaveAddr, alignment);
    result = result && entry->Read(&structure->serBroadcastAddr, alignment);
    result = result && entry->Read(&structure->serChipIdAddr, alignment);
    result = result && entry->Read(&structure->sensorSlaveAddr, alignment);
    result = result && entry->Read(&structure->sensorChipIdAddr, alignment);

    // Reading Array desAliasInfo from symbol table
    {
        result = result && entry->Read(&structure->desAliasInfoCount, alignment);
        structure->desAliasInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->desAliasInfo = PARAMETER_NEW GmslAliasInfo[structure->desAliasInfoCount];
        }
        if (!result || structure->desAliasInfo == NULL)
        {
            structure->desAliasInfoCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->desAliasInfoCount; i++)
        {
            result = LoadGmslAliasInfo(pointerEntry, &structure->desAliasInfo[i], alignment);
        }
    }

    // Reading Array serAliasInfo from symbol table
    {
        result = result && entry->Read(&structure->serAliasInfoCount, alignment);
        structure->serAliasInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->serAliasInfo = PARAMETER_NEW GmslAliasInfo[structure->serAliasInfoCount];
        }
        if (!result || structure->serAliasInfo == NULL)
        {
            structure->serAliasInfoCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->serAliasInfoCount; i++)
        {
            result = LoadGmslAliasInfo(pointerEntry, &structure->serAliasInfo[i], alignment);
        }
    }

    // Reading Array sensorAliasInfo from symbol table
    {
        result = result && entry->Read(&structure->sensorAliasInfoCount, alignment);
        structure->sensorAliasInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->sensorAliasInfo = PARAMETER_NEW GmslAliasInfo[structure->sensorAliasInfoCount];
        }
        if (!result || structure->sensorAliasInfo == NULL)
        {
            structure->sensorAliasInfoCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->sensorAliasInfoCount; i++)
        {
            result = LoadGmslAliasInfo(pointerEntry, &structure->sensorAliasInfo[i], alignment);
        }
    }

    // Reading Array enableForwardSettings from symbol table
    {
        result = result && entry->Read(&structure->enableForwardSettingsCount, alignment);
        structure->enableForwardSettingsID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->enableForwardSettings = PARAMETER_NEW GmslSettings[structure->enableForwardSettingsCount];
        }
        if (!result || structure->enableForwardSettings == NULL)
        {
            structure->enableForwardSettingsCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->enableForwardSettingsCount; i++)
        {
            result = LoadGmslSettings(pointerEntry, &structure->enableForwardSettings[i], alignment);
        }
    }

    // Reading Array disableForwardSettings from symbol table
    {
        result = result && entry->Read(&structure->disableForwardSettingsCount, alignment);
        structure->disableForwardSettingsID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->disableForwardSettings = PARAMETER_NEW GmslSettings[structure->disableForwardSettingsCount];
        }
        if (!result || structure->disableForwardSettings == NULL)
        {
            structure->disableForwardSettingsCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->disableForwardSettingsCount; i++)
        {
            result = LoadGmslSettings(pointerEntry, &structure->disableForwardSettings[i], alignment);
        }
    }

    // Reading Array remapSettings from symbol table
    {
        result = result && entry->Read(&structure->remapSettingsCount, alignment);
        structure->remapSettingsID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->remapSettings = PARAMETER_NEW GmslSettings[structure->remapSettingsCount];
        }
        if (!result || structure->remapSettings == NULL)
        {
            structure->remapSettingsCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->remapSettingsCount; i++)
        {
            result = LoadGmslSettings(pointerEntry, &structure->remapSettings[i], alignment);
        }
    }

    // Reading Array streamOnSettings from symbol table
    {
        result = result && entry->Read(&structure->streamOnSettingsCount, alignment);
        structure->streamOnSettingsID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->streamOnSettings = PARAMETER_NEW GmslSettings[structure->streamOnSettingsCount];
        }
        if (!result || structure->streamOnSettings == NULL)
        {
            structure->streamOnSettingsCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->streamOnSettingsCount; i++)
        {
            result = LoadGmslSettings(pointerEntry, &structure->streamOnSettings[i], alignment);
        }
    }

    // Reading Array streamOffSettings from symbol table
    {
        result = result && entry->Read(&structure->streamOffSettingsCount, alignment);
        structure->streamOffSettingsID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->streamOffSettings = PARAMETER_NEW GmslSettings[structure->streamOffSettingsCount];
        }
        if (!result || structure->streamOffSettings == NULL)
        {
            structure->streamOffSettingsCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->streamOffSettingsCount; i++)
        {
            result = LoadGmslSettings(pointerEntry, &structure->streamOffSettings[i], alignment);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load TemperatureInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadTemperatureInformation(
    ParameterFileSymbolTableEntry* entry,
    TemperatureInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->temperatureSlaveAddr, alignment);
    result = result && camxsensorcommonClass::LoadSettingsInfo(entry, &structure->initSetting, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ColorLevelInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadColorLevelInformation(
    ParameterFileSymbolTableEntry* entry,
    ColorLevelInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->whiteLevel, alignment);
    result = result && entry->Read(&structure->rPedestal, alignment);
    result = result && entry->Read(&structure->grPedestal, alignment);
    result = result && entry->Read(&structure->bPedestal, alignment);
    result = result && entry->Read(&structure->gbPedestal, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load OpticalBlackRegionInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadOpticalBlackRegionInfo(
    ParameterFileSymbolTableEntry* entry,
    OpticalBlackRegionInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading Array dimension from symbol table
    {
        result = entry->Read(&structure->dimensionCount, alignment);
        structure->dimensionID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->dimension = PARAMETER_NEW FrameDimension[structure->dimensionCount];
        }
        if (!result || structure->dimension == NULL)
        {
            structure->dimensionCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->dimensionCount; i++)
        {
            result = camxsensorcommonClass::LoadFrameDimension(pointerEntry, &structure->dimension[i], alignment);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load PixelArrayInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadPixelArrayInfo(
    ParameterFileSymbolTableEntry* entry,
    PixelArrayInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = camxsensorcommonClass::LoadDimension(entry, &structure->activeDimension, alignment);
    result = result && LoadBorderInformation(entry, &structure->dummyInfo, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load DelayInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadDelayInfo(
    ParameterFileSymbolTableEntry* entry,
    DelayInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading Optional parameter linecount from symbol table
    {
        result = entry->Read(&structure->linecountExists, alignment);
        structure->linecountID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->linecountExists)
        {
            result = pointerEntry->Read(&structure->linecount, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->linecount);
        }
    }

    // Reading Optional parameter gain from symbol table
    {
        result = result && entry->Read(&structure->gainExists, alignment);
        structure->gainID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->gainExists)
        {
            result = result && pointerEntry->Read(&structure->gain, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->gain);
        }
    }

    // Reading Optional parameter frameLengthLines from symbol table
    {
        result = result && entry->Read(&structure->frameLengthLinesExists, alignment);
        structure->frameLengthLinesID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->frameLengthLinesExists)
        {
            result = result && pointerEntry->Read(&structure->frameLengthLines, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->frameLengthLines);
        }
    }
    result = result && entry->Read(&structure->maxPipeline, alignment);
    result = result && entry->Read(&structure->frameSkip, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load SensorProperty
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadSensorProperty(
    ParameterFileSymbolTableEntry* entry,
    SensorProperty* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->pixelSize, alignment);
    result = result && entry->Read(&structure->cropFactor, alignment);
    structure->sensingMethod = (SensingMethod)entry->ReadEnum(&result, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load NoiseCoefficent
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadNoiseCoefficent(
    ParameterFileSymbolTableEntry* entry,
    NoiseCoefficent* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->gradient_S, alignment);
    result = result && entry->Read(&structure->offset_S, alignment);
    result = result && entry->Read(&structure->gradient_O, alignment);
    result = result && entry->Read(&structure->offset_O, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load NoiseCoefficientBayer
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadNoiseCoefficientBayer(
    ParameterFileSymbolTableEntry* entry,
    NoiseCoefficientBayer* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadNoiseCoefficent(entry, &structure->R, alignment);
    result = result && LoadNoiseCoefficent(entry, &structure->Gr, alignment);
    result = result && LoadNoiseCoefficent(entry, &structure->Gb, alignment);
    result = result && LoadNoiseCoefficent(entry, &structure->B, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load EnumDefinition
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadEnumDefinition(
    ParameterFileSymbolTableEntry* entry,
    EnumDefinition* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading Optional parameter noiseCoefficientChannel from symbol table
    {
        result = entry->Read(&structure->noiseCoefficientChannelExists, alignment);
        structure->noiseCoefficientChannelID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->noiseCoefficientChannelExists)
        {
            structure->noiseCoefficientChannel = (NoiseCoefficientChannel)pointerEntry->ReadEnum(&result, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->noiseCoefficientChannel);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load SensorDriverData
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::LoadSensorDriverData(
    ParameterFileSymbolTableEntry* entry,
    SensorDriverData* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = Loadmodule_versionStruct(entry, &structure->module_version, alignment);
    result = result && LoadSlaveInformation(entry, &structure->slaveInfo, alignment);
    result = result && LoadRegAddrInformation(entry, &structure->regAddrInfo, alignment);

    // Reading Array resolutionInfo from symbol table
    {
        result = result && entry->Read(&structure->resolutionInfoCount, alignment);
        structure->resolutionInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->resolutionInfo = PARAMETER_NEW ResolutionInformation[structure->resolutionInfoCount];
        }
        if (!result || structure->resolutionInfo == NULL)
        {
            structure->resolutionInfoCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->resolutionInfoCount; i++)
        {
            result = LoadResolutionInformation(pointerEntry, &structure->resolutionInfo[i], alignment);
        }
    }
    result = result && LoadExposureContorlInformation(entry, &structure->exposureControlInfo, alignment);
    result = result && camxsensorcommonClass::LoadSettingsInfo(entry, &structure->streamOnSettings, alignment);
    result = result && camxsensorcommonClass::LoadSettingsInfo(entry, &structure->streamOffSettings, alignment);
    result = result && camxsensorcommonClass::LoadSettingsInfo(entry, &structure->groupHoldOnSettings, alignment);
    result = result && camxsensorcommonClass::LoadSettingsInfo(entry, &structure->groupHoldOffSettings, alignment);

    // Reading Optional parameter masterSettings from symbol table
    {
        result = result && entry->Read(&structure->masterSettingsExists, alignment);
        structure->masterSettingsID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->masterSettingsExists)
        {
            result = result && camxsensorcommonClass::LoadSettingsInfo(pointerEntry, &structure->masterSettings, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->masterSettings);
        }
    }

    // Reading Optional parameter slaveSettings from symbol table
    {
        result = result && entry->Read(&structure->slaveSettingsExists, alignment);
        structure->slaveSettingsID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->slaveSettingsExists)
        {
            result = result && camxsensorcommonClass::LoadSettingsInfo(pointerEntry, &structure->slaveSettings, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->slaveSettings);
        }
    }

    // Reading Array initSettings from symbol table
    {
        result = result && entry->Read(&structure->initSettingsCount, alignment);
        structure->initSettingsID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->initSettings = PARAMETER_NEW InitSettings[structure->initSettingsCount];
        }
        if (!result || structure->initSettings == NULL)
        {
            structure->initSettingsCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->initSettingsCount; i++)
        {
            result = LoadInitSettings(pointerEntry, &structure->initSettings[i], alignment);
        }
    }
    result = result && LoadTestPatternInformation(entry, &structure->testPatternInfo, alignment);

    // Reading Optional parameter gmslInfo from symbol table
    {
        result = result && entry->Read(&structure->gmslInfoExists, alignment);
        structure->gmslInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->gmslInfoExists)
        {
            result = result && LoadGmslInformation(pointerEntry, &structure->gmslInfo, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->gmslInfo);
        }
    }

    // Reading Optional parameter TemperatureInfo from symbol table
    {
        result = result && entry->Read(&structure->TemperatureInfoExists, alignment);
        structure->TemperatureInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->TemperatureInfoExists)
        {
            result = result && LoadTemperatureInformation(pointerEntry, &structure->TemperatureInfo, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->TemperatureInfo);
        }
    }
    result = result && LoadColorLevelInformation(entry, &structure->colorLevelInfo, alignment);
    result = result && LoadOpticalBlackRegionInfo(entry, &structure->opticalBlackRegionInfo, alignment);
    result = result && LoadPixelArrayInfo(entry, &structure->pixelArrayInfo, alignment);
    result = result && LoadDelayInfo(entry, &structure->delayInfo, alignment);
    result = result && LoadSensorProperty(entry, &structure->sensorProperty, alignment);

    // Reading Optional parameter noiseCoefficent from symbol table
    {
        result = result && entry->Read(&structure->noiseCoefficentExists, alignment);
        structure->noiseCoefficentID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->noiseCoefficentExists)
        {
            result = result && LoadNoiseCoefficent(pointerEntry, &structure->noiseCoefficent, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->noiseCoefficent);
        }
    }

    // Reading Optional parameter noiseCoefficientBayer from symbol table
    {
        result = result && entry->Read(&structure->noiseCoefficientBayerExists, alignment);
        structure->noiseCoefficientBayerID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->noiseCoefficientBayerExists)
        {
            result = result && LoadNoiseCoefficientBayer(pointerEntry, &structure->noiseCoefficientBayer, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->noiseCoefficientBayer);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load module_versionStruct
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL SensorDriverDataClass::Loadmodule_versionStruct(
    ParameterFileSymbolTableEntry* entry,
    SensorDriverData::module_versionStruct* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->major_revision, alignment);
    result = result && entry->Read(&structure->minor_revision, alignment);
    result = result && entry->Read(&structure->incr_revision, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload SlaveInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SensorDriverDataClass::UnloadSlaveInformation(
    SlaveInformation* structure)
{
    PARAMETER_DELETE[] structure->sensorName;
    camxsensorcommonClass::UnloadPowerSequenceInfo(&structure->powerUpSequence);
    camxsensorcommonClass::UnloadPowerSequenceInfo(&structure->powerDownSequence);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload StreamInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SensorDriverDataClass::UnloadStreamInformation(
    StreamInformation* structure)
{
    PARAMETER_DELETE[] structure->streamConfiguration;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload HDR3ExposureInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SensorDriverDataClass::UnloadHDR3ExposureInformation(
    HDR3ExposureInformation* structure)
{
    camxsensorcommonClass::UnloadSettingsInfo(&structure->InSensorHDR3ExpStartSettings);
    camxsensorcommonClass::UnloadSettingsInfo(&structure->InSensorHDR3ExpStopSettings);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload ResolutionData
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SensorDriverDataClass::UnloadResolutionData(
    ResolutionData* structure)
{
    UnloadStreamInformation(&structure->streamInfo);
    camxsensorcommonClass::UnloadSettingsInfo(&structure->resSettings);
    UnloadHDR3ExposureInformation(&structure->HDR3ExposureInfo);
    PARAMETER_DELETE[] structure->capability;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload ResolutionInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SensorDriverDataClass::UnloadResolutionInformation(
    ResolutionInformation* structure)
{
    for (UINT32 i = 0; i < structure->resolutionDataCount; i++)
    {
        UnloadResolutionData(&structure->resolutionData[i]);
    }
    PARAMETER_DELETE[] structure->resolutionData;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload InitSettings
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SensorDriverDataClass::UnloadInitSettings(
    InitSettings* structure)
{
    camxsensorcommonClass::UnloadSettingsInfo(&structure->initSetting);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload ExposureContorlInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SensorDriverDataClass::UnloadExposureContorlInformation(
    ExposureContorlInformation* structure)
{
    PARAMETER_DELETE[] structure->realToRegGain;
    PARAMETER_DELETE[] structure->regToRealGain;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload TestPatternData
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SensorDriverDataClass::UnloadTestPatternData(
    TestPatternData* structure)
{
    camxsensorcommonClass::UnloadSettingsInfo(&structure->settings);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload TestPatternInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SensorDriverDataClass::UnloadTestPatternInformation(
    TestPatternInformation* structure)
{
    for (UINT32 i = 0; i < structure->testPatternDataCount; i++)
    {
        UnloadTestPatternData(&structure->testPatternData[i]);
    }
    PARAMETER_DELETE[] structure->testPatternData;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload GmslSettings
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SensorDriverDataClass::UnloadGmslSettings(
    GmslSettings* structure)
{
    camxsensorcommonClass::UnloadSettingsInfo(&structure->gmslSetting);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload GmslInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SensorDriverDataClass::UnloadGmslInformation(
    GmslInformation* structure)
{
    PARAMETER_DELETE[] structure->desAliasInfo;
    PARAMETER_DELETE[] structure->serAliasInfo;
    PARAMETER_DELETE[] structure->sensorAliasInfo;
    for (UINT32 i = 0; i < structure->enableForwardSettingsCount; i++)
    {
        UnloadGmslSettings(&structure->enableForwardSettings[i]);
    }
    PARAMETER_DELETE[] structure->enableForwardSettings;
    for (UINT32 i = 0; i < structure->disableForwardSettingsCount; i++)
    {
        UnloadGmslSettings(&structure->disableForwardSettings[i]);
    }
    PARAMETER_DELETE[] structure->disableForwardSettings;
    for (UINT32 i = 0; i < structure->remapSettingsCount; i++)
    {
        UnloadGmslSettings(&structure->remapSettings[i]);
    }
    PARAMETER_DELETE[] structure->remapSettings;
    for (UINT32 i = 0; i < structure->streamOnSettingsCount; i++)
    {
        UnloadGmslSettings(&structure->streamOnSettings[i]);
    }
    PARAMETER_DELETE[] structure->streamOnSettings;
    for (UINT32 i = 0; i < structure->streamOffSettingsCount; i++)
    {
        UnloadGmslSettings(&structure->streamOffSettings[i]);
    }
    PARAMETER_DELETE[] structure->streamOffSettings;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload TemperatureInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SensorDriverDataClass::UnloadTemperatureInformation(
    TemperatureInformation* structure)
{
    camxsensorcommonClass::UnloadSettingsInfo(&structure->initSetting);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload OpticalBlackRegionInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SensorDriverDataClass::UnloadOpticalBlackRegionInfo(
    OpticalBlackRegionInfo* structure)
{
    PARAMETER_DELETE[] structure->dimension;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload SensorDriverData
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SensorDriverDataClass::UnloadSensorDriverData(
    SensorDriverData* structure)
{
    UnloadSlaveInformation(&structure->slaveInfo);
    for (UINT32 i = 0; i < structure->resolutionInfoCount; i++)
    {
        UnloadResolutionInformation(&structure->resolutionInfo[i]);
    }
    PARAMETER_DELETE[] structure->resolutionInfo;
    UnloadExposureContorlInformation(&structure->exposureControlInfo);
    camxsensorcommonClass::UnloadSettingsInfo(&structure->streamOnSettings);
    camxsensorcommonClass::UnloadSettingsInfo(&structure->streamOffSettings);
    camxsensorcommonClass::UnloadSettingsInfo(&structure->groupHoldOnSettings);
    camxsensorcommonClass::UnloadSettingsInfo(&structure->groupHoldOffSettings);
    camxsensorcommonClass::UnloadSettingsInfo(&structure->masterSettings);
    camxsensorcommonClass::UnloadSettingsInfo(&structure->slaveSettings);
    for (UINT32 i = 0; i < structure->initSettingsCount; i++)
    {
        UnloadInitSettings(&structure->initSettings[i]);
    }
    PARAMETER_DELETE[] structure->initSettings;
    UnloadTestPatternInformation(&structure->testPatternInfo);
    UnloadGmslInformation(&structure->gmslInfo);
    UnloadTemperatureInformation(&structure->TemperatureInfo);
    UnloadOpticalBlackRegionInfo(&structure->opticalBlackRegionInfo);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Parse symbol table entry, and return a new object
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ParameterModule* SensorDriverDataClass::Parse(
    ParameterFileSymbolTableEntry* entry,
    UINT64 alignment) const
{
    SensorDriverDataClass* cls = NULL;

    if (PARAMETER_STRCMP(Type, entry->Type) == 0 && Version.Value == entry->Version.Value)
    {
        cls = PARAMETER_NEW SensorDriverDataClass(GetName(entry->Type), 
            entry->ModeId, entry->Mode);
        if (cls != NULL)
        {
            BOOL result = TRUE;

            cls->SymbolTableID = entry->ID;
            cls->ID            = entry->ID;

            result = result && LoadSensorDriverData(entry, cls, alignment);

            if (!result)
            {
                PARAMETER_DELETE cls;
                cls = NULL;
            }
        }
    }
    return (ParameterModule*)cls;
}


CAMX_NAMESPACE_END
