////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2023 Qualcomm Technologies, Inc.
// All Rights Reserved.
// Confidential and Proprietary - Qualcomm Technologies, Inc.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// THIS IS AUTO-GENERATED CODE.  PLEASE DO NOT EDIT (File bug reports against tools).
///
/// Auto-generated by: Parameter Parser V2.0.0 (1907311625)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file  camxactuatordriver.cpp
/// @brief Auto-generated Chromatix parameter file
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "camxactuatordriver.h"
#include "parametersetmanager.h"

CAMX_NAMESPACE_BEGIN

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Default Constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ActuatorDriverDataClass::ActuatorDriverDataClass(
    const CHAR* name)
    : ParameterModule(name, VersionUnion(MAJOR, MINOR, PATCH), 0, ModeUnion(0))
{
    PARAMETER_INITIALIZE(SymbolTableID);
    PARAMETER_INITIALIZE(module_version);
    PARAMETER_INITIALIZE(slaveInfo);
    PARAMETER_INITIALIZE(registerConfig);
    PARAMETER_INITIALIZE(initSettings);
    PARAMETER_INITIALIZE(deInitSettingsExists);
    PARAMETER_INITIALIZE(deInitSettingsID);
    PARAMETER_INITIALIZE(deInitSettings);
    PARAMETER_INITIALIZE(tunedParams);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ActuatorDriverDataClass::ActuatorDriverDataClass(
    const CHAR* name,
    UINT32      modeId,
    ModeUnion   mode)
    : ParameterModule(name, VersionUnion(MAJOR, MINOR, PATCH), modeId, mode)
{
    PARAMETER_INITIALIZE(SymbolTableID);
    PARAMETER_INITIALIZE(module_version);
    PARAMETER_INITIALIZE(slaveInfo);
    PARAMETER_INITIALIZE(registerConfig);
    PARAMETER_INITIALIZE(initSettings);
    PARAMETER_INITIALIZE(deInitSettings);
    PARAMETER_INITIALIZE(tunedParams);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Destructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ActuatorDriverDataClass::~ActuatorDriverDataClass()
{
    UnloadActuatorDriverData(this);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GetName
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const CHAR* ActuatorDriverDataClass::GetName(
    const CHAR* type)
{
    const CHAR* name = type;
    CHAR temp[ParameterFileSymbolTableEntry::TYPE_LEN + 1];
    if (PARAMETER_STRCMP(type, ParameterFileSymbolTableEntry::GetType(temp, "actuatorDriver")) == 0)
    {
        name = "actuatorDriver";
    }
    if (PARAMETER_STRCMP(type, ParameterFileSymbolTableEntry::GetType(temp, "actuatorDriver1")) == 0)
    {
        name = "actuatorDriver1";
    }
    return name;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ActuatorSlaveInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ActuatorDriverDataClass::LoadActuatorSlaveInfo(
    ParameterFileSymbolTableEntry* entry,
    ActuatorSlaveInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading String actuatorName from symbol table
    {
        UINT32 count = 0;
        result = entry->Read(&count, alignment);
        ParameterFileSymbolTableEntry* stringPointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && stringPointerEntry != NULL;
        structure->actuatorName = NULL;
        result = result && stringPointerEntry->ReadString(&structure->actuatorName, count, alignment);
    }

    // Reading Optional parameter actuatorID from symbol table
    {
        result = result && entry->Read(&structure->actuatorIDExists, alignment);
        structure->actuatorIDID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->actuatorIDExists)
        {
            result = result && pointerEntry->Read(&structure->actuatorID, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->actuatorID);
        }
    }
    result = result && entry->Read(&structure->slaveAddress, alignment);
    structure->i2cFrequencyMode = (I2CFrequencyMode)entry->ReadEnum(&result, alignment);
    structure->actuatorType = (ActuatorType)entry->ReadEnum(&result, alignment);
    result = result && entry->Read(&structure->dataBitWidth, alignment);
    result = result && camxsensorcommonClass::LoadPowerSequenceInfo(entry, &structure->powerUpSequence, alignment);
    result = result && camxsensorcommonClass::LoadPowerSequenceInfo(entry, &structure->powerDownSequence, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ActuatorRegParam
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ActuatorDriverDataClass::LoadActuatorRegParam(
    ParameterFileSymbolTableEntry* entry,
    ActuatorRegParam* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->regAddrType, alignment);
    result = result && entry->Read(&structure->regDataType, alignment);
    result = result && entry->Read(&structure->registerAddr, alignment);
    result = result && entry->Read(&structure->registerData, alignment);
    structure->operation = (ActuatorOperation)entry->ReadEnum(&result, alignment);
    result = result && entry->Read(&structure->delayUs, alignment);
    result = result && entry->Read(&structure->hwMask, alignment);
    result = result && entry->Read(&structure->hwShift, alignment);
    result = result && entry->Read(&structure->dataShift, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ActuatorRegConfig
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ActuatorDriverDataClass::LoadActuatorRegConfig(
    ParameterFileSymbolTableEntry* entry,
    ActuatorRegConfig* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading Array registerParam from symbol table
    {
        result = entry->Read(&structure->registerParamCount, alignment);
        structure->registerParamID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->registerParam = PARAMETER_NEW ActuatorRegParam[structure->registerParamCount];
        }
        if (!result || structure->registerParam == NULL)
        {
            structure->registerParamCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->registerParamCount; i++)
        {
            result = LoadActuatorRegParam(pointerEntry, &structure->registerParam[i], alignment);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ActuatorRegionParams
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ActuatorDriverDataClass::LoadActuatorRegionParams(
    ParameterFileSymbolTableEntry* entry,
    ActuatorRegionParams* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->macroStepBoundary, alignment);
    result = result && entry->Read(&structure->infinityStepBoundary, alignment);
    result = result && entry->Read(&structure->codePerStep, alignment);
    result = result && entry->Read(&structure->qValue, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ActuatorRegionParamsArray
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ActuatorDriverDataClass::LoadActuatorRegionParamsArray(
    ParameterFileSymbolTableEntry* entry,
    ActuatorRegionParamsArray* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading Array region from symbol table
    {
        result = entry->Read(&structure->regionCount, alignment);
        structure->regionID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->region = PARAMETER_NEW ActuatorRegionParams[structure->regionCount];
        }
        if (!result || structure->region == NULL)
        {
            structure->regionCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->regionCount; i++)
        {
            result = LoadActuatorRegionParams(pointerEntry, &structure->region[i], alignment);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ActuatorDampingParams
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ActuatorDriverDataClass::LoadActuatorDampingParams(
    ParameterFileSymbolTableEntry* entry,
    ActuatorDampingParams* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->dampingStep, alignment);
    result = result && entry->Read(&structure->dampingDelayUs, alignment);
    result = result && entry->Read(&structure->hwParams, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load RegionDampingParamsArray
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ActuatorDriverDataClass::LoadRegionDampingParamsArray(
    ParameterFileSymbolTableEntry* entry,
    RegionDampingParamsArray* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading Array region from symbol table
    {
        result = entry->Read(&structure->regionCount, alignment);
        structure->regionID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->region = PARAMETER_NEW ActuatorDampingParams[structure->regionCount];
        }
        if (!result || structure->region == NULL)
        {
            structure->regionCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->regionCount; i++)
        {
            result = LoadActuatorDampingParams(pointerEntry, &structure->region[i], alignment);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ScenarioDampingParamsArray
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ActuatorDriverDataClass::LoadScenarioDampingParamsArray(
    ParameterFileSymbolTableEntry* entry,
    ScenarioDampingParamsArray* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading Array scenario from symbol table
    {
        result = entry->Read(&structure->scenarioCount, alignment);
        structure->scenarioID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->scenario = PARAMETER_NEW RegionDampingParamsArray[structure->scenarioCount];
        }
        if (!result || structure->scenario == NULL)
        {
            structure->scenarioCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->scenarioCount; i++)
        {
            result = LoadRegionDampingParamsArray(pointerEntry, &structure->scenario[i], alignment);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ActuatorDampingInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ActuatorDriverDataClass::LoadActuatorDampingInfo(
    ParameterFileSymbolTableEntry* entry,
    ActuatorDampingInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->ringingScenario, alignment);
    result = result && LoadScenarioDampingParamsArray(entry, &structure->scenarioDampingParams, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ActuatorTunedParams
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ActuatorDriverDataClass::LoadActuatorTunedParams(
    ParameterFileSymbolTableEntry* entry,
    ActuatorTunedParams* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->initialCode, alignment);
    result = result && LoadActuatorRegionParamsArray(entry, &structure->regionParams, alignment);
    result = result && LoadActuatorDampingInfo(entry, &structure->forwardDamping, alignment);
    result = result && LoadActuatorDampingInfo(entry, &structure->backwardDamping, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load ActuatorDriverData
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ActuatorDriverDataClass::LoadActuatorDriverData(
    ParameterFileSymbolTableEntry* entry,
    ActuatorDriverData* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = Loadmodule_versionStruct(entry, &structure->module_version, alignment);
    result = result && LoadActuatorSlaveInfo(entry, &structure->slaveInfo, alignment);
    result = result && LoadActuatorRegConfig(entry, &structure->registerConfig, alignment);
    result = result && camxsensorcommonClass::LoadSettingsInfo(entry, &structure->initSettings, alignment);

    // Reading Optional parameter deInitSettings from symbol table
    {
        result = result && entry->Read(&structure->deInitSettingsExists, alignment);
        structure->deInitSettingsID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->deInitSettingsExists)
        {
            result = result && camxsensorcommonClass::LoadSettingsInfo(pointerEntry, &structure->deInitSettings, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->deInitSettings);
        }
    }
    result = result && LoadActuatorTunedParams(entry, &structure->tunedParams, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load module_versionStruct
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ActuatorDriverDataClass::Loadmodule_versionStruct(
    ParameterFileSymbolTableEntry* entry,
    ActuatorDriverData::module_versionStruct* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->major_revision, alignment);
    result = result && entry->Read(&structure->minor_revision, alignment);
    result = result && entry->Read(&structure->incr_revision, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload ActuatorSlaveInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ActuatorDriverDataClass::UnloadActuatorSlaveInfo(
    ActuatorSlaveInfo* structure)
{
    PARAMETER_DELETE[] structure->actuatorName;
    camxsensorcommonClass::UnloadPowerSequenceInfo(&structure->powerUpSequence);
    camxsensorcommonClass::UnloadPowerSequenceInfo(&structure->powerDownSequence);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload ActuatorRegConfig
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ActuatorDriverDataClass::UnloadActuatorRegConfig(
    ActuatorRegConfig* structure)
{
    PARAMETER_DELETE[] structure->registerParam;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload ActuatorRegionParamsArray
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ActuatorDriverDataClass::UnloadActuatorRegionParamsArray(
    ActuatorRegionParamsArray* structure)
{
    PARAMETER_DELETE[] structure->region;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload RegionDampingParamsArray
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ActuatorDriverDataClass::UnloadRegionDampingParamsArray(
    RegionDampingParamsArray* structure)
{
    PARAMETER_DELETE[] structure->region;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload ScenarioDampingParamsArray
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ActuatorDriverDataClass::UnloadScenarioDampingParamsArray(
    ScenarioDampingParamsArray* structure)
{
    for (UINT32 i = 0; i < structure->scenarioCount; i++)
    {
        UnloadRegionDampingParamsArray(&structure->scenario[i]);
    }
    PARAMETER_DELETE[] structure->scenario;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload ActuatorDampingInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ActuatorDriverDataClass::UnloadActuatorDampingInfo(
    ActuatorDampingInfo* structure)
{
    UnloadScenarioDampingParamsArray(&structure->scenarioDampingParams);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload ActuatorTunedParams
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ActuatorDriverDataClass::UnloadActuatorTunedParams(
    ActuatorTunedParams* structure)
{
    UnloadActuatorRegionParamsArray(&structure->regionParams);
    UnloadActuatorDampingInfo(&structure->forwardDamping);
    UnloadActuatorDampingInfo(&structure->backwardDamping);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload ActuatorDriverData
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ActuatorDriverDataClass::UnloadActuatorDriverData(
    ActuatorDriverData* structure)
{
    UnloadActuatorSlaveInfo(&structure->slaveInfo);
    UnloadActuatorRegConfig(&structure->registerConfig);
    camxsensorcommonClass::UnloadSettingsInfo(&structure->initSettings);
    camxsensorcommonClass::UnloadSettingsInfo(&structure->deInitSettings);
    UnloadActuatorTunedParams(&structure->tunedParams);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Parse symbol table entry, and return a new object
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ParameterModule* ActuatorDriverDataClass::Parse(
    ParameterFileSymbolTableEntry* entry,
    UINT64 alignment) const
{
    ActuatorDriverDataClass* cls = NULL;

    if (PARAMETER_STRCMP(Type, entry->Type) == 0 && Version.Value == entry->Version.Value)
    {
        cls = PARAMETER_NEW ActuatorDriverDataClass(GetName(entry->Type), 
            entry->ModeId, entry->Mode);
        if (cls != NULL)
        {
            BOOL result = TRUE;

            cls->SymbolTableID = entry->ID;
            cls->ID            = entry->ID;

            result = result && LoadActuatorDriverData(entry, cls, alignment);

            if (!result)
            {
                PARAMETER_DELETE cls;
                cls = NULL;
            }
        }
    }
    return (ParameterModule*)cls;
}


CAMX_NAMESPACE_END
