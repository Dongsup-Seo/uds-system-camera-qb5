////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2023 Qualcomm Technologies, Inc.
// All Rights Reserved.
// Confidential and Proprietary - Qualcomm Technologies, Inc.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// THIS IS AUTO-GENERATED CODE.  PLEASE DO NOT EDIT (File bug reports against tools).
///
/// Auto-generated by: Parameter Parser V2.0.0 (1907311625)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file  camxeepromdriver.cpp
/// @brief Auto-generated Chromatix parameter file
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "camxeepromdriver.h"
#include "parametersetmanager.h"

CAMX_NAMESPACE_BEGIN

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Default Constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
EEPROMDriverDataClass::EEPROMDriverDataClass(
    const CHAR* name)
    : ParameterModule(name, VersionUnion(MAJOR, MINOR, PATCH), 0, ModeUnion(0))
{
    PARAMETER_INITIALIZE(SymbolTableID);
    PARAMETER_INITIALIZE(module_version);
    PARAMETER_INITIALIZE(slaveInfo);
    PARAMETER_INITIALIZE(memoryMap);
    PARAMETER_INITIALIZE(formatInfo);
    PARAMETER_INITIALIZE(customInfoCount);
    PARAMETER_INITIALIZE(customInfoID);
    PARAMETER_INITIALIZE(customInfo);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
EEPROMDriverDataClass::EEPROMDriverDataClass(
    const CHAR* name,
    UINT32      modeId,
    ModeUnion   mode)
    : ParameterModule(name, VersionUnion(MAJOR, MINOR, PATCH), modeId, mode)
{
    PARAMETER_INITIALIZE(SymbolTableID);
    PARAMETER_INITIALIZE(module_version);
    PARAMETER_INITIALIZE(slaveInfo);
    PARAMETER_INITIALIZE(memoryMap);
    PARAMETER_INITIALIZE(formatInfo);
    PARAMETER_INITIALIZE(customInfo);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Destructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
EEPROMDriverDataClass::~EEPROMDriverDataClass()
{
    UnloadEEPROMDriverData(this);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GetName
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const CHAR* EEPROMDriverDataClass::GetName(
    const CHAR* type)
{
    const CHAR* name = type;
    CHAR temp[ParameterFileSymbolTableEntry::TYPE_LEN + 1];
    if (PARAMETER_STRCMP(type, ParameterFileSymbolTableEntry::GetType(temp, "EEPROMDriverData")) == 0)
    {
        name = "EEPROMDriverData";
    }
    return name;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load EEPROMSlaveInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadEEPROMSlaveInformation(
    ParameterFileSymbolTableEntry* entry,
    EEPROMSlaveInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading String EEPROMName from symbol table
    {
        UINT32 count = 0;
        result = entry->Read(&count, alignment);
        ParameterFileSymbolTableEntry* stringPointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && stringPointerEntry != NULL;
        structure->EEPROMName = NULL;
        result = result && stringPointerEntry->ReadString(&structure->EEPROMName, count, alignment);
    }
    result = result && entry->Read(&structure->slaveAddress, alignment);
    result = result && entry->Read(&structure->regAddrType, alignment);
    result = result && entry->Read(&structure->regDataType, alignment);
    structure->i2cFrequencyMode = (I2CFrequencyMode)entry->ReadEnum(&result, alignment);
    result = result && camxsensorcommonClass::LoadPowerSequenceInfo(entry, &structure->powerUpSequence, alignment);
    result = result && camxsensorcommonClass::LoadPowerSequenceInfo(entry, &structure->powerDownSequence, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load MemoryType
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadMemoryType(
    ParameterFileSymbolTableEntry* entry,
    MemoryType* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->isAvailable, alignment);
    structure->endianness = (EndianType)entry->ReadEnum(&result, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load MemoryInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadMemoryInfo(
    ParameterFileSymbolTableEntry* entry,
    MemoryInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->offset, alignment);
    result = result && entry->Read(&structure->mask, alignment);
    structure->signedness = (SignType)entry->ReadEnum(&result, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load AFCalibrationInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadAFCalibrationInfo(
    ParameterFileSymbolTableEntry* entry,
    AFCalibrationInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadMemoryInfo(entry, &structure->chartDistanceCM, alignment);
    result = result && LoadMemoryInfo(entry, &structure->DACValue, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load AFInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadAFInfo(
    ParameterFileSymbolTableEntry* entry,
    AFInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadMemoryType(entry, &structure->autoFocusData, alignment);
    result = result && LoadMemoryInfo(entry, &structure->macro, alignment);
    result = result && LoadMemoryInfo(entry, &structure->infinity, alignment);

    // Reading Array calibrationInfo from symbol table
    {
        result = result && entry->Read(&structure->calibrationInfoCount, alignment);
        structure->calibrationInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->calibrationInfo = PARAMETER_NEW AFCalibrationInfo[structure->calibrationInfoCount];
        }
        if (!result || structure->calibrationInfo == NULL)
        {
            structure->calibrationInfoCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->calibrationInfoCount; i++)
        {
            result = LoadAFCalibrationInfo(pointerEntry, &structure->calibrationInfo[i], alignment);
        }
    }
    result = result && LoadMemoryInfo(entry, &structure->hall, alignment);
    result = result && LoadMemoryInfo(entry, &structure->hallBias, alignment);
    result = result && entry->Read(&structure->hallRegisterAddr, alignment);
    result = result && LoadMemoryInfo(entry, &structure->verticalMacro, alignment);
    result = result && LoadMemoryInfo(entry, &structure->verticalInfinity, alignment);
    result = result && LoadMemoryInfo(entry, &structure->horizontalMacro, alignment);
    result = result && LoadMemoryInfo(entry, &structure->horizontalInfinity, alignment);
    result = result && entry->Read(&structure->macroMargin, alignment);
    result = result && entry->Read(&structure->infinityMargin, alignment);
    structure->lensSagCalMac = (AfLensSagType)entry->ReadEnum(&result, alignment);
    structure->lensSagCalInf = (AfLensSagType)entry->ReadEnum(&result, alignment);
    result = result && LoadMemoryInfo(entry, &structure->otpGravityOfs0to90, alignment);
    result = result && LoadMemoryInfo(entry, &structure->otpGravityOfs90to180, alignment);
    result = result && entry->Read(&structure->avgGravityOfs0to90, alignment);
    result = result && entry->Read(&structure->avgGravityOfs90to180, alignment);

    // Reading Optional parameter actuatorID from symbol table
    {
        result = result && entry->Read(&structure->actuatorIDExists, alignment);
        structure->actuatorIDID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->actuatorIDExists)
        {
            result = result && LoadMemoryInfo(pointerEntry, &structure->actuatorID, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->actuatorID);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load SPCSettingsInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadSPCSettingsInfo(
    ParameterFileSymbolTableEntry* entry,
    SPCSettingsInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadMemoryInfo(entry, &structure->dataOffset, alignment);
    result = result && entry->Read(&structure->SPCAddress, alignment);
    result = result && entry->Read(&structure->settingsSize, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load WBlightInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadWBlightInfo(
    ParameterFileSymbolTableEntry* entry,
    WBlightInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    structure->illuminantType = (EEPROMIlluminantType)entry->ReadEnum(&result, alignment);
    result = result && LoadMemoryInfo(entry, &structure->rValue, alignment);
    result = result && LoadMemoryInfo(entry, &structure->grValue, alignment);
    result = result && LoadMemoryInfo(entry, &structure->bValue, alignment);
    result = result && LoadMemoryInfo(entry, &structure->gbValue, alignment);
    result = result && LoadMemoryInfo(entry, &structure->rOverGValue, alignment);
    result = result && LoadMemoryInfo(entry, &structure->bOverGValue, alignment);
    result = result && LoadMemoryInfo(entry, &structure->grOverGBValue, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load WBInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadWBInfo(
    ParameterFileSymbolTableEntry* entry,
    WBInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadMemoryType(entry, &structure->WBData, alignment);
    structure->datatype = (WBType)entry->ReadEnum(&result, alignment);

    // Reading Array lightInfo from symbol table
    {
        result = result && entry->Read(&structure->lightInfoCount, alignment);
        structure->lightInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->lightInfo = PARAMETER_NEW WBlightInfo[structure->lightInfoCount];
        }
        if (!result || structure->lightInfo == NULL)
        {
            structure->lightInfoCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->lightInfoCount; i++)
        {
            result = LoadWBlightInfo(pointerEntry, &structure->lightInfo[i], alignment);
        }
    }
    result = result && LoadMemoryInfo(entry, &structure->mirror, alignment);
    result = result && LoadMemoryInfo(entry, &structure->flip, alignment);
    result = result && entry->Read(&structure->qValue, alignment);
    result = result && entry->Read(&structure->isInvertGROverGB, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load LSClightInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadLSClightInfo(
    ParameterFileSymbolTableEntry* entry,
    LSClightInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    structure->illuminantType = (EEPROMIlluminantType)entry->ReadEnum(&result, alignment);
    result = result && LoadMemoryInfo(entry, &structure->rGainMSB, alignment);
    result = result && LoadMemoryInfo(entry, &structure->rGainLSB, alignment);
    result = result && LoadMemoryInfo(entry, &structure->grGainMSB, alignment);
    result = result && LoadMemoryInfo(entry, &structure->grGainLSB, alignment);
    result = result && LoadMemoryInfo(entry, &structure->gbGainMSB, alignment);
    result = result && LoadMemoryInfo(entry, &structure->gbGainLSB, alignment);
    result = result && LoadMemoryInfo(entry, &structure->bGainMSB, alignment);
    result = result && LoadMemoryInfo(entry, &structure->bGainLSB, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load LSCInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadLSCInfo(
    ParameterFileSymbolTableEntry* entry,
    LSCInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadMemoryType(entry, &structure->LSCData, alignment);

    // Reading Array lightInfo from symbol table
    {
        result = result && entry->Read(&structure->lightInfoCount, alignment);
        structure->lightInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->lightInfo = PARAMETER_NEW LSClightInfo[structure->lightInfoCount];
        }
        if (!result || structure->lightInfo == NULL)
        {
            structure->lightInfoCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->lightInfoCount; i++)
        {
            result = LoadLSClightInfo(pointerEntry, &structure->lightInfo[i], alignment);
        }
    }
    result = result && entry->Read(&structure->meshHWRollOffSize, alignment);
    result = result && entry->Read(&structure->rIncrement, alignment);
    result = result && entry->Read(&structure->grIncrement, alignment);
    result = result && entry->Read(&structure->gbIncrement, alignment);
    result = result && entry->Read(&structure->bIncrement, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load AbsoluteMethodAECSyncInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadAbsoluteMethodAECSyncInfo(
    ParameterFileSymbolTableEntry* entry,
    AbsoluteMethodAECSyncInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadMemoryInfo(entry, &structure->version, alignment);
    result = result && LoadMemoryInfo(entry, &structure->averageLuma, alignment);
    result = result && LoadMemoryInfo(entry, &structure->gain, alignment);
    result = result && LoadMemoryInfo(entry, &structure->exposureTimeUs, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load DualCameraLensInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadDualCameraLensInfo(
    ParameterFileSymbolTableEntry* entry,
    DualCameraLensInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadMemoryInfo(entry, &structure->focalLength, alignment);
    result = result && LoadMemoryInfo(entry, &structure->focalLengthRatio, alignment);
    result = result && LoadMemoryInfo(entry, &structure->nativeSensorResolutionWidth, alignment);
    result = result && LoadMemoryInfo(entry, &structure->nativeSensorResolutionHeight, alignment);
    result = result && LoadMemoryInfo(entry, &structure->calibrationResolutionWidth, alignment);
    result = result && LoadMemoryInfo(entry, &structure->calibrationResolutionHeight, alignment);

    // Reading Array AFSyncInfo from symbol table
    {
        result = result && entry->Read(&structure->AFSyncInfoCount, alignment);
        structure->AFSyncInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->AFSyncInfo = PARAMETER_NEW AFCalibrationInfo[structure->AFSyncInfoCount];
        }
        if (!result || structure->AFSyncInfo == NULL)
        {
            structure->AFSyncInfoCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->AFSyncInfoCount; i++)
        {
            result = LoadAFCalibrationInfo(pointerEntry, &structure->AFSyncInfo[i], alignment);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load DualCameraSystemInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadDualCameraSystemInfo(
    ParameterFileSymbolTableEntry* entry,
    DualCameraSystemInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadMemoryInfo(entry, &structure->calibrationFormatVersion, alignment);
    result = result && entry->Read(&structure->rotationMatrixSize, alignment);
    result = result && LoadMemoryInfo(entry, &structure->relativeRotationMatrixOffset, alignment);
    result = result && entry->Read(&structure->geometricMatrixSize, alignment);
    result = result && LoadMemoryInfo(entry, &structure->relativeGeometricSurfaceParametersOffset, alignment);
    result = result && LoadMemoryInfo(entry, &structure->relativePrinciplePointX, alignment);
    result = result && LoadMemoryInfo(entry, &structure->relativePrinciplePointY, alignment);
    result = result && LoadMemoryInfo(entry, &structure->relativePositionFlag, alignment);
    result = result && LoadMemoryInfo(entry, &structure->relativeBaselineDistance, alignment);
    result = result && LoadMemoryInfo(entry, &structure->masterSensorMirrorFlipSetting, alignment);
    result = result && LoadMemoryInfo(entry, &structure->auxSensorMirrorFlipSetting, alignment);
    result = result && LoadMemoryInfo(entry, &structure->moduleOrientationFlag, alignment);
    result = result && LoadMemoryInfo(entry, &structure->rotationFlag, alignment);

    // Reading Optional parameter brightnessRatio from symbol table
    {
        result = result && entry->Read(&structure->brightnessRatioExists, alignment);
        structure->brightnessRatioID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->brightnessRatioExists)
        {
            result = result && LoadMemoryInfo(pointerEntry, &structure->brightnessRatio, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->brightnessRatio);
        }
    }

    // Reading Optional parameter referenceSlaveGain from symbol table
    {
        result = result && entry->Read(&structure->referenceSlaveGainExists, alignment);
        structure->referenceSlaveGainID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->referenceSlaveGainExists)
        {
            result = result && LoadMemoryInfo(pointerEntry, &structure->referenceSlaveGain, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->referenceSlaveGain);
        }
    }

    // Reading Optional parameter referenceSlaveExpTime from symbol table
    {
        result = result && entry->Read(&structure->referenceSlaveExpTimeExists, alignment);
        structure->referenceSlaveExpTimeID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->referenceSlaveExpTimeExists)
        {
            result = result && LoadMemoryInfo(pointerEntry, &structure->referenceSlaveExpTime, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->referenceSlaveExpTime);
        }
    }

    // Reading Optional parameter referenceMasterGain from symbol table
    {
        result = result && entry->Read(&structure->referenceMasterGainExists, alignment);
        structure->referenceMasterGainID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->referenceMasterGainExists)
        {
            result = result && LoadMemoryInfo(pointerEntry, &structure->referenceMasterGain, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->referenceMasterGain);
        }
    }

    // Reading Optional parameter referenceMasterExpTime from symbol table
    {
        result = result && entry->Read(&structure->referenceMasterExpTimeExists, alignment);
        structure->referenceMasterExpTimeID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->referenceMasterExpTimeExists)
        {
            result = result && LoadMemoryInfo(pointerEntry, &structure->referenceMasterExpTime, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->referenceMasterExpTime);
        }
    }

    // Reading Optional parameter referenceMasterColorTemp from symbol table
    {
        result = result && entry->Read(&structure->referenceMasterColorTempExists, alignment);
        structure->referenceMasterColorTempID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->referenceMasterColorTempExists)
        {
            result = result && LoadMemoryInfo(pointerEntry, &structure->referenceMasterColorTemp, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->referenceMasterColorTemp);
        }
    }

    // Reading Optional parameter qValue from symbol table
    {
        result = result && entry->Read(&structure->qValueExists, alignment);
        structure->qValueID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->qValueExists)
        {
            result = result && pointerEntry->Read(&structure->qValue, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->qValue);
        }
    }

    // Reading Optional parameter absoluteMethodAECSyncInfo from symbol table
    {
        result = result && entry->Read(&structure->absoluteMethodAECSyncInfoExists, alignment);
        structure->absoluteMethodAECSyncInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->absoluteMethodAECSyncInfoExists)
        {
            result = result && LoadAbsoluteMethodAECSyncInfo(pointerEntry, &structure->absoluteMethodAECSyncInfo, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->absoluteMethodAECSyncInfo);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load DualCameraInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadDualCameraInfo(
    ParameterFileSymbolTableEntry* entry,
    DualCameraInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadMemoryType(entry, &structure->DualCameraData, alignment);
    result = result && entry->Read(&structure->offset, alignment);
    result = result && entry->Read(&structure->settingsize, alignment);
    result = result && LoadDualCameraLensInfo(entry, &structure->masterInfo, alignment);
    result = result && LoadDualCameraLensInfo(entry, &structure->auxInfo, alignment);
    result = result && LoadDualCameraSystemInfo(entry, &structure->systemInfo, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load SPCInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadSPCInfo(
    ParameterFileSymbolTableEntry* entry,
    SPCInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadMemoryType(entry, &structure->SPCData, alignment);

    // Reading Array SPCSettings from symbol table
    {
        result = result && entry->Read(&structure->SPCSettingsCount, alignment);
        structure->SPCSettingsID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->SPCSettings = PARAMETER_NEW SPCSettingsInfo[structure->SPCSettingsCount];
        }
        if (!result || structure->SPCSettings == NULL)
        {
            structure->SPCSettingsCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->SPCSettingsCount; i++)
        {
            result = LoadSPCSettingsInfo(pointerEntry, &structure->SPCSettings[i], alignment);
        }
    }
    result = result && entry->Read(&structure->addressType, alignment);
    result = result && entry->Read(&structure->dataType, alignment);
    result = result && entry->Read(&structure->delay, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load OISInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadOISInfo(
    ParameterFileSymbolTableEntry* entry,
    OISInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadMemoryType(entry, &structure->OISData, alignment);
    result = result && LoadMemoryInfo(entry, &structure->dataOffset, alignment);

    // Reading Array OISAddressArray from symbol table
    {
        result = result && entry->Read(&structure->OISAddressArrayCount, alignment);
        structure->OISAddressArrayID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->OISAddressArray = pointerEntry->ReadArray<UINT32>(structure->OISAddressArrayCount, alignment);
            result = structure->OISAddressArray != NULL;
        }
        if (!result || structure->OISAddressArray == NULL)
        {
            structure->OISAddressArrayCount = 0;
        }
    }
    result = result && entry->Read(&structure->settingsSize, alignment);
    result = result && entry->Read(&structure->addressType, alignment);
    result = result && entry->Read(&structure->dataType, alignment);
    result = result && entry->Read(&structure->delay, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load PDAFDCCInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadPDAFDCCInfo(
    ParameterFileSymbolTableEntry* entry,
    PDAFDCCInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadMemoryType(entry, &structure->DCCData, alignment);
    result = result && LoadMemoryInfo(entry, &structure->slopeDataOffset, alignment);
    result = result && LoadMemoryInfo(entry, &structure->offsetDataOffset, alignment);
    result = result && entry->Read(&structure->knotX, alignment);
    result = result && entry->Read(&structure->knotY, alignment);
    result = result && entry->Read(&structure->offsetX, alignment);
    result = result && entry->Read(&structure->offsetY, alignment);
    result = result && entry->Read(&structure->areaX, alignment);
    result = result && entry->Read(&structure->areaY, alignment);
    result = result && entry->Read(&structure->qValue, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load PDAF2DInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadPDAF2DInfo(
    ParameterFileSymbolTableEntry* entry,
    PDAF2DInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadMemoryType(entry, &structure->PDAF2DData, alignment);
    result = result && LoadMemoryInfo(entry, &structure->version, alignment);
    result = result && LoadMemoryInfo(entry, &structure->mapWidth, alignment);
    result = result && LoadMemoryInfo(entry, &structure->mapHeight, alignment);
    result = result && entry->Read(&structure->gainWidth, alignment);
    result = result && entry->Read(&structure->gainHeight, alignment);
    result = result && LoadMemoryInfo(entry, &structure->leftGainMap, alignment);
    result = result && LoadMemoryInfo(entry, &structure->rightGainMap, alignment);

    // Reading Optional parameter upGainMap from symbol table
    {
        result = result && entry->Read(&structure->upGainMapExists, alignment);
        structure->upGainMapID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->upGainMapExists)
        {
            result = result && LoadMemoryInfo(pointerEntry, &structure->upGainMap, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->upGainMap);
        }
    }

    // Reading Optional parameter downGainMap from symbol table
    {
        result = result && entry->Read(&structure->downGainMapExists, alignment);
        structure->downGainMapID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->downGainMapExists)
        {
            result = result && LoadMemoryInfo(pointerEntry, &structure->downGainMap, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->downGainMap);
        }
    }
    result = result && entry->Read(&structure->conversionCoefficientCount, alignment);
    result = result && LoadMemoryInfo(entry, &structure->conversionCoefficient, alignment);

    // Reading Optional parameter DCCQFormat from symbol table
    {
        result = result && entry->Read(&structure->DCCQFormatExists, alignment);
        structure->DCCQFormatID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->DCCQFormatExists)
        {
            result = result && pointerEntry->Read(&structure->DCCQFormat, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->DCCQFormat);
        }
    }

    // Reading Optional parameter DCCMapWidth from symbol table
    {
        result = result && entry->Read(&structure->DCCMapWidthExists, alignment);
        structure->DCCMapWidthID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->DCCMapWidthExists)
        {
            result = result && pointerEntry->Read(&structure->DCCMapWidth, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->DCCMapWidth);
        }
    }

    // Reading Optional parameter DCCMapHeight from symbol table
    {
        result = result && entry->Read(&structure->DCCMapHeightExists, alignment);
        structure->DCCMapHeightID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->DCCMapHeightExists)
        {
            result = result && pointerEntry->Read(&structure->DCCMapHeight, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->DCCMapHeight);
        }
    }

    // Reading Optional parameter DCCQFormatMemoryInfo from symbol table
    {
        result = result && entry->Read(&structure->DCCQFormatMemoryInfoExists, alignment);
        structure->DCCQFormatMemoryInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->DCCQFormatMemoryInfoExists)
        {
            result = result && LoadMemoryInfo(pointerEntry, &structure->DCCQFormatMemoryInfo, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->DCCQFormatMemoryInfo);
        }
    }

    // Reading Optional parameter DCCMapWidthMemoryInfo from symbol table
    {
        result = result && entry->Read(&structure->DCCMapWidthMemoryInfoExists, alignment);
        structure->DCCMapWidthMemoryInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->DCCMapWidthMemoryInfoExists)
        {
            result = result && LoadMemoryInfo(pointerEntry, &structure->DCCMapWidthMemoryInfo, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->DCCMapWidthMemoryInfo);
        }
    }

    // Reading Optional parameter DCCMapHeightMemoryInfo from symbol table
    {
        result = result && entry->Read(&structure->DCCMapHeightMemoryInfoExists, alignment);
        structure->DCCMapHeightMemoryInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result && structure->DCCMapHeightMemoryInfoExists)
        {
            result = result && LoadMemoryInfo(pointerEntry, &structure->DCCMapHeightMemoryInfo, alignment);
        }
        else
        {
            PARAMETER_INITIALIZE(structure->DCCMapHeightMemoryInfo);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load LensDistortionInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadLensDistortionInfo(
    ParameterFileSymbolTableEntry* entry,
    LensDistortionInfo* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadMemoryType(entry, &structure->lensData, alignment);
    result = result && entry->Read(&structure->lensOffsetStart, alignment);
    result = result && entry->Read(&structure->lensDistortionSize, alignment);
    result = result && LoadMemoryInfo(entry, &structure->horizontalFocalLength, alignment);
    result = result && LoadMemoryInfo(entry, &structure->verticalFocalLength, alignment);
    result = result && LoadMemoryInfo(entry, &structure->opticalAxisX, alignment);
    result = result && LoadMemoryInfo(entry, &structure->opticalAxisY, alignment);
    result = result && LoadMemoryInfo(entry, &structure->kappa0, alignment);
    result = result && LoadMemoryInfo(entry, &structure->kappa1, alignment);
    result = result && LoadMemoryInfo(entry, &structure->kappa2, alignment);
    result = result && LoadMemoryInfo(entry, &structure->kappa3, alignment);
    result = result && LoadMemoryInfo(entry, &structure->kappa4, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load EEPROMDataFormatInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadEEPROMDataFormatInformation(
    ParameterFileSymbolTableEntry* entry,
    EEPROMDataFormatInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = LoadAFInfo(entry, &structure->AF, alignment);
    result = result && LoadWBInfo(entry, &structure->WB, alignment);
    result = result && LoadLSCInfo(entry, &structure->LSC, alignment);
    result = result && LoadDualCameraInfo(entry, &structure->dualCamera, alignment);
    result = result && LoadSPCInfo(entry, &structure->SPC, alignment);
    result = result && LoadOISInfo(entry, &structure->OIS, alignment);
    result = result && LoadPDAFDCCInfo(entry, &structure->PDAFDCC, alignment);
    result = result && LoadPDAF2DInfo(entry, &structure->PDAF2D, alignment);
    result = result && LoadLensDistortionInfo(entry, &structure->Lens, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load CustomInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadCustomInformation(
    ParameterFileSymbolTableEntry* entry,
    CustomInformation* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;


    // Reading String name from symbol table
    {
        UINT32 count = 0;
        result = entry->Read(&count, alignment);
        ParameterFileSymbolTableEntry* stringPointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && stringPointerEntry != NULL;
        structure->name = NULL;
        result = result && stringPointerEntry->ReadString(&structure->name, count, alignment);
    }
    result = result && entry->Read(&structure->value, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load EEPROMDriverData
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::LoadEEPROMDriverData(
    ParameterFileSymbolTableEntry* entry,
    EEPROMDriverData* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = Loadmodule_versionStruct(entry, &structure->module_version, alignment);
    result = result && LoadEEPROMSlaveInformation(entry, &structure->slaveInfo, alignment);
    result = result && camxsensorcommonClass::LoadSettingsInfo(entry, &structure->memoryMap, alignment);
    result = result && LoadEEPROMDataFormatInformation(entry, &structure->formatInfo, alignment);

    // Reading Array customInfo from symbol table
    {
        result = result && entry->Read(&structure->customInfoCount, alignment);
        structure->customInfoID = entry->ID;
        ParameterFileSymbolTableEntry* pointerEntry = entry->Table->ReadPointerEntry(entry, alignment);
        result = result && pointerEntry != NULL;
        if (result)
        {
            structure->customInfo = PARAMETER_NEW CustomInformation[structure->customInfoCount];
        }
        if (!result || structure->customInfo == NULL)
        {
            structure->customInfoCount = 0;
        }
        for (UINT32 i = 0; result && i < structure->customInfoCount; i++)
        {
            result = LoadCustomInformation(pointerEntry, &structure->customInfo[i], alignment);
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Load module_versionStruct
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL EEPROMDriverDataClass::Loadmodule_versionStruct(
    ParameterFileSymbolTableEntry* entry,
    EEPROMDriverData::module_versionStruct* structure,
    UINT64 alignment)
{
    BOOL result = TRUE;

    result = entry->Read(&structure->major_revision, alignment);
    result = result && entry->Read(&structure->minor_revision, alignment);
    result = result && entry->Read(&structure->incr_revision, alignment);

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload EEPROMSlaveInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void EEPROMDriverDataClass::UnloadEEPROMSlaveInformation(
    EEPROMSlaveInformation* structure)
{
    PARAMETER_DELETE[] structure->EEPROMName;
    camxsensorcommonClass::UnloadPowerSequenceInfo(&structure->powerUpSequence);
    camxsensorcommonClass::UnloadPowerSequenceInfo(&structure->powerDownSequence);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload AFInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void EEPROMDriverDataClass::UnloadAFInfo(
    AFInfo* structure)
{
    PARAMETER_DELETE[] structure->calibrationInfo;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload WBInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void EEPROMDriverDataClass::UnloadWBInfo(
    WBInfo* structure)
{
    PARAMETER_DELETE[] structure->lightInfo;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload LSCInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void EEPROMDriverDataClass::UnloadLSCInfo(
    LSCInfo* structure)
{
    PARAMETER_DELETE[] structure->lightInfo;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload DualCameraLensInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void EEPROMDriverDataClass::UnloadDualCameraLensInfo(
    DualCameraLensInfo* structure)
{
    PARAMETER_DELETE[] structure->AFSyncInfo;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload DualCameraInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void EEPROMDriverDataClass::UnloadDualCameraInfo(
    DualCameraInfo* structure)
{
    UnloadDualCameraLensInfo(&structure->masterInfo);
    UnloadDualCameraLensInfo(&structure->auxInfo);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload SPCInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void EEPROMDriverDataClass::UnloadSPCInfo(
    SPCInfo* structure)
{
    PARAMETER_DELETE[] structure->SPCSettings;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload OISInfo
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void EEPROMDriverDataClass::UnloadOISInfo(
    OISInfo* structure)
{
    PARAMETER_DELETE[] structure->OISAddressArray;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload EEPROMDataFormatInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void EEPROMDriverDataClass::UnloadEEPROMDataFormatInformation(
    EEPROMDataFormatInformation* structure)
{
    UnloadAFInfo(&structure->AF);
    UnloadWBInfo(&structure->WB);
    UnloadLSCInfo(&structure->LSC);
    UnloadDualCameraInfo(&structure->dualCamera);
    UnloadSPCInfo(&structure->SPC);
    UnloadOISInfo(&structure->OIS);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload CustomInformation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void EEPROMDriverDataClass::UnloadCustomInformation(
    CustomInformation* structure)
{
    PARAMETER_DELETE[] structure->name;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Unload EEPROMDriverData
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void EEPROMDriverDataClass::UnloadEEPROMDriverData(
    EEPROMDriverData* structure)
{
    UnloadEEPROMSlaveInformation(&structure->slaveInfo);
    camxsensorcommonClass::UnloadSettingsInfo(&structure->memoryMap);
    UnloadEEPROMDataFormatInformation(&structure->formatInfo);
    for (UINT32 i = 0; i < structure->customInfoCount; i++)
    {
        UnloadCustomInformation(&structure->customInfo[i]);
    }
    PARAMETER_DELETE[] structure->customInfo;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Parse symbol table entry, and return a new object
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ParameterModule* EEPROMDriverDataClass::Parse(
    ParameterFileSymbolTableEntry* entry,
    UINT64 alignment) const
{
    EEPROMDriverDataClass* cls = NULL;

    if (PARAMETER_STRCMP(Type, entry->Type) == 0 && Version.Value == entry->Version.Value)
    {
        cls = PARAMETER_NEW EEPROMDriverDataClass(GetName(entry->Type), 
            entry->ModeId, entry->Mode);
        if (cls != NULL)
        {
            BOOL result = TRUE;

            cls->SymbolTableID = entry->ID;
            cls->ID            = entry->ID;

            result = result && LoadEEPROMDriverData(entry, cls, alignment);

            if (!result)
            {
                PARAMETER_DELETE cls;
                cls = NULL;
            }
        }
    }
    return (ParameterModule*)cls;
}


CAMX_NAMESPACE_END
