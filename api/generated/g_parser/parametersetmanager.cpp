////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2023 Qualcomm Technologies, Inc.
// All Rights Reserved.
// Confidential and Proprietary - Qualcomm Technologies, Inc.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// THIS IS AUTO-GENERATED CODE.  PLEASE DO NOT EDIT (File bug reports against tools).
///
/// Auto-generated by: Parameter Parser V2.0.0 (1907311625)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file  parametersetmanager.cpp
/// @brief Auto-generated Chromatix parameter file
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "parametersetmanager.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// class ModeEntry
///
/// @brief Contains an mode tree data.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Constructor
///
/// @brief  Constructs the ModeEntry class
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ModeEntry::ModeEntry()
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Destructor
///
/// @brief  Destructs the ModeEntry class
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ModeEntry::~ModeEntry()
{
    FirstChild = NULL;
    LastChild  = NULL;
    FirstGroup = NULL;
    LastGroup  = NULL;

    Next = NULL;

    PARAMETER_DELETE FirstModule;
    FirstModule = NULL;
    LastModule  = NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Initialize
///
/// @brief  Initializes the ModeEntry class
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID ModeEntry::Initialize(
    UINT32 id,
    ModeUnion mode,
    ModeEntry* link)
{
    Id          = id;
    Mode        = mode;
    Link        = link;
    Parent      = NULL;
    FirstChild  = NULL;
    LastChild   = NULL;
    FirstGroup  = NULL;
    LastGroup   = NULL;
    Next        = NULL;
    FirstModule = NULL;
    LastModule  = NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Add
///
/// @brief  Adds a child ModeEntry
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID ModeEntry::AddMode(
    ModeEntry* child)
{
    if (child != NULL)
    {
        child->Parent = this;

        if (Mode.IsModeMatch(child->Mode))
        {
            // This mode is the same mode/sub mode as its parent, therefore it is differentiated by group.
            // Group value is not part of the ModeEntry class because the actual group value does not matter,
            // since modules in different groups are also differentiated by name.
            // Group modes hold the actual module data for the mode.
            if (FirstGroup == NULL)
            {
                FirstGroup = child;
            }
            else
            {
                LastGroup->Next = child;
            }
            LastGroup = child;
        }
        else
        {
            // Child modes define the mode tree structure
            if (FirstChild == NULL)
            {
                FirstChild = child;
            }
            else
            {
                LastChild->Next = child;
            }
            LastChild  = child;
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Add
///
/// @brief  Adds a Module
///
/// @return Returns the ModeEntry object or NULL, if not found
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ModeEntry::AddModule(
   ParameterModule* module)
{
    if (module != NULL)
    {
        if (FirstModule == NULL)
        {
            FirstModule = module;
        }
        else
        {
            LastModule->Next = module;
        }

        LastModule  = module;
    }

    return module != NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ReplaceModule
///
/// @brief  Replaces existing or adds a new Module.
///
/// @return Replaced module, NULL if this is a new module
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ParameterModule* ModeEntry::ReplaceModule(
    ParameterModule* newModule)
{
    ParameterModule* replaced = NULL;
    if (newModule != NULL)
    {
        if (FirstModule == NULL)
        {
            FirstModule           = newModule;
            LastModule            = newModule;
            newModule->ModeId     = Id;
            newModule->Mode.Value = Mode.Value;
            newModule->Next       = NULL;
        }
        else
        {
            ParameterModule** module = &FirstModule;
            while (*module != NULL)
            {
                if (PARAMETER_STRCMP((*module)->Name, newModule->Name) == 0)
                {
                    // Found, replace
                    replaced = *module;

                    newModule->ModeId     = Id;
                    newModule->Mode.Value = Mode.Value;
                    newModule->Next       = replaced->Next;

                    // Replaced is last module, update last module pointer
                    if (LastModule == replaced)
                    {
                        LastModule = newModule;
                    }

                    // Replace module
                    *module = newModule;
                    break;
                }
                else
                {
                    module = &(*module)->Next;
                }
            }

            // Not found, add new
            if (replaced == NULL)
            {
                newModule->ModeId     = Id;
                newModule->Mode.Value = Mode.Value;
                newModule->Next       = NULL;
                LastModule->Next      = newModule;
            }
        }
    }

    return replaced;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FindMode
///
/// @brief  Finds a ModeEntry, in the mode tree, from a mode id
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ModeEntry* ModeEntry::FindMode(
   UINT32 id)
{
    ModeEntry* result = NULL;
    if (Id == id)
    {
        result = this;
    }
    else
    {
        if (Link != NULL)
        {
            result = Link->FindMode(id);
        }
        else
        {
            ModeEntry* child = FirstGroup;
            while (result == NULL && child != NULL)
            {
                result = child->FindMode(id);
                child  = child->Next;
            }

            if (result == NULL)
            {
                child = FirstChild;
                while (result == NULL && child != NULL)
                {
                    result = child->FindMode(id);
                    child = child->Next;
                }
            }
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FindMode
///
/// @brief  Finds a ModeEntry, in children, from a mode, subMode
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ModeEntry* ModeEntry::FindMode(
   TuningMode* mode)
{
    ModeEntry* result = NULL;

    if (Link != NULL)
    {
        result = Link->FindMode(mode);
    }
    else
    {
        ModeEntry* child = FirstChild;
        while (result == NULL && child != NULL)
        {
            if ((UINT16)mode->mode  == child->Mode.Mode.Mode &&
                mode->subMode.value == child->Mode.Mode.SubMode)
            {
                result = child;
            }
            else
            {
                child = child->Next;
            }
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FindMode
///
/// @brief  Finds a ModeEntry, in children, from a mode/subMode array
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ModeEntry* ModeEntry::FindMode(
    TuningMode* modes,
    UINT32 count,
    UINT32 found)
{
    ModeEntry* result = NULL;

    if (Link != NULL)
    {
        result = Link->FindMode(modes, count, found);
    }
    else
    {
        for (UINT32 index = 0; result == NULL && index < count; index++)
        {
            result = FindMode(&modes[index]);

            if (result != NULL && found + 1 < count)
            {
                result = result->FindMode(modes, count, found + 1);
            }
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FindModule
///
/// @brief  Finds a Module from a module name id
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ParameterModule* ModeEntry::FindModule(
   const CHAR* moduleName)
{
    ParameterModule* result = NULL;

    if (Link != NULL)
    {
        result = Link->FindModule(moduleName);
    }
    else
    {
        ParameterModule* module = FirstModule;
        while (result == NULL && module != NULL)
        {
            if (PARAMETER_STRCMP(module->Name, moduleName) == 0)
            {
                result = module;
            }
            module = module->Next;
        }

        ModeEntry* child = FirstGroup;
        while (result == NULL && child != NULL)
        {
            result = child->FindModule(moduleName);
            child = child->Next;
        }
    }
    return result;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ParameterSetManager
///
/// @brief Manages the parameter set
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// LoadBinaryParameters
///
/// @brief Loads binary parameters from a buffer
///
/// @param buffer   Binary parameter buffer
/// @param length   Length of the binary parameter buffer
///
/// @return Node
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ParameterSetManager::LoadBinaryParameters(
    UINT8* buffer,
    UINT64 length)
{
    UINT64 pos       = 0;
    UINT32 offset    = 0;
    UINT32 count     = 0;
    UINT64 alignment = 1;

    Valid = FALSE;

    if (ReadHeader(buffer, length, &pos, &offset, &count, &alignment))
    {
        pos   = (INT32)offset;
        Valid = ReadSections(buffer, length, &pos, count, this, alignment);
    }

    return Valid;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FreeReplacedParameters
///
/// @brief Frees any Parameter objects that were replaced with a call to UpdateParameters
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ParameterSetManager::FreeReplacedParameters()
{
    if (m_firstReplaced != NULL)
    {
        PARAMETER_DELETE(m_firstReplaced);
        m_firstReplaced = NULL;
    }

    m_lastReplaced = NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// UpdateParameters
///
/// @brief Replaces exising parameters.
///
/// @param parameters   ParameterSetManager object to use for replacement parameters. Parameters are removed from this object.
///
/// @return True if no errors occur
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ParameterSetManager::UpdateParameters(
    ParameterSetManager* parameters)
{
    BOOL result = FALSE;

    if (Valid && parameters != NULL && parameters->m_rootMode != NULL)
    {
        result = UpdateParameters(m_rootMode, parameters->m_rootMode);
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// UpdateParameters
///
/// @brief Replaces exising parameters.
///
/// @param parameters   ParameterSetManager object to use for replacement parameters. Parameters are removed from this object.
///
/// @return True if no errors occur
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ParameterSetManager::UpdateParameters(
    ModeEntry* destinationRoot,
    ModeEntry* sourceRoot)
{
    BOOL result = FALSE;

    if (destinationRoot != NULL && sourceRoot != NULL)
    {
        ModeEntry* sourceGroup = sourceRoot->FirstGroup;

        result = TRUE;
        while (result && sourceGroup != NULL)
        {
            if (sourceGroup->FirstModule != NULL)
            {
                // This source group contains modules, replace them in the matching destination group

                // Find matching destination group
                ModeEntry* destinationGroup = destinationRoot->FirstGroup;
                while (destinationGroup != NULL &&
                    destinationGroup->Mode.Mode.Group != sourceGroup->Mode.Mode.Group)
                {
                    destinationGroup = destinationGroup->Next;
                }

                if (destinationGroup != NULL && destinationGroup->Link == NULL) // Linked destination nodes may not be replaced
                {
                    // Replace modules

                    while (sourceGroup->FirstModule != NULL)
                    {
                        ParameterModule* newModule = sourceGroup->FirstModule;
                        sourceGroup->FirstModule   = newModule->Next;
                        ParameterModule* replaced = destinationGroup->ReplaceModule(newModule);
                        if (replaced != NULL)
                        {
                            if (m_firstReplaced == NULL)
                            {
                                m_firstReplaced = replaced;
                            }
                            else
                            {
                                m_lastReplaced->Next = replaced;
                            }
                            m_lastReplaced = replaced;
                        }
                    }

                    result = TRUE;
                }
            }

            // Move to the next source group
            sourceGroup = sourceGroup->Next;
        }

        result = TRUE;

        // Process the child modes
        ModeEntry* sourceChild = sourceRoot->FirstChild;
        while (result && sourceChild != NULL)
        {
            // Find matching destination root child
            TuningMode tm;
            tm.mode          = (ModeType)sourceChild->Mode.Mode.Mode;
            tm.subMode.value = sourceChild->Mode.Mode.SubMode;
            ModeEntry* destinationChild = destinationRoot->FindMode(&tm);

            result = UpdateParameters(destinationChild, sourceChild);

            sourceChild = sourceChild->Next;
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GetModule
///
/// @brief Returns first parameter module matching the name, mode, selector, and selectorData
///
/// @param name         Module name
/// @param modeBranch   Mode branch
/// @param modeCount    Mode count
///
/// @return The first parameter module found matching the name and mode.  Version is ignored.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ParameterModule* ParameterSetManager::GetModule(
    const CHAR* name,
    TuningMode* modeBranch,
    UINT32      modeCount)
{
    ParameterModule* result = NULL;

    if (m_rootMode != NULL)
    {
        ModeEntry* mode = m_rootMode;

        result = mode->FindModule(name);

        // First mode must always been root, start at index 1
        UINT32 index = 1;
        while (mode != NULL && index < modeCount)
        {
            UINT32 sameModeCount = 1;

            while (index + sameModeCount < modeCount && modeBranch[index].mode == modeBranch[index + sameModeCount].mode)
            {
                sameModeCount++;
            }

            mode = mode->FindMode(&modeBranch[index], sameModeCount, 0);

            if (mode != NULL)
            {
                ParameterModule* module = mode->FindModule(name);
                if (module != NULL)
                {
                    result = module;
                }
            }

            index += sameModeCount;
        }
    }
    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GetModeEntry
///
/// @brief Gets the Mode and SubMode from a given Mode ID
///
/// @param modeID    Mode ID
/// @param mode      Mode for the Mode ID [out]
///
/// @return TRUE if ModeID was found, otherwise FALSE
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ParameterSetManager::GetModeEntry(
    UINT32 modeID,
    ModeUnion* mode)
{
    BOOL result = FALSE;
    mode->Value = 0;
    if (m_modes != NULL && modeID < m_modeCount)
    {
        *mode  = m_modes[modeID].Mode;
        result = TRUE;
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GetModeEntry
///
/// @brief Gets the Mode and SubMode from a given Mode ID
///
/// @param modeBranch   Mode branch
/// @param modeCount    Mode count
///
/// @return ModeEntry if found, otherwise NULL
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ModeEntry* ParameterSetManager::GetModeEntry(
    TuningMode* modeBranch,
    UINT32      modeCount)
{
    ModeEntry* result = NULL;

    if (m_rootMode != NULL)
    {
        ModeEntry* mode = m_rootMode;

        // First mode must always been root, start at index 1
        UINT32 index = 1;
        while (mode != NULL && index < modeCount)
        {
            UINT32 sameModeCount = 1;

            while (index + sameModeCount < modeCount && modeBranch[index].mode == modeBranch[index + sameModeCount].mode)
            {
                sameModeCount++;
            }

            mode = mode->FindMode(&modeBranch[index], sameModeCount, 0);

            index += sameModeCount;
        }

        result = mode;
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ParameterSetManager
///
/// @brief Constructor
///
/// @return Node
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ParameterSetManager::ParameterSetManager()
{
    Valid           = FALSE;
    Error[0]        = '\0';
    m_rootMode      = NULL;
    m_modes         = NULL;
    m_modeCount     = 0;
    m_firstReplaced = NULL;
    m_lastReplaced  = NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ~ParameterSetManager
///
/// @brief Destructor
///
/// @return Node
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ParameterSetManager::~ParameterSetManager()
{
    if (m_modes != NULL)
    {
        PARAMETER_DELETE[]  m_modes;
        m_modes = NULL;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ReadHeader
///
/// @brief Reads and validates the the binary parameter file header
///
/// @param buffer    Binary parameter buffer
/// @param length    Length of the binary parameter buffer
/// @param pos       Current position in the the binary parameter buffer [in/out]
/// @param offset    Offset to the section buffer [out]
/// @param count     Section count [out]
/// @param alignment Bianry data alignment [out]
///
/// @return True if successful
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ParameterSetManager::ReadHeader(
    UINT8*  buffer,
    UINT64  length,
    UINT64* pos,
    UINT32* offset,
    UINT32* count,
    UINT64* alignment)
{
    BOOL         result    = TRUE;
    CHAR*        tag       = NULL;
    CHAR*        tool      = NULL;
    CHAR*        binaryTag = NULL;
    UINT32       size      = 0;
    CHAR         error[ERROR_LEN];

    // Header alignment is always 1 for backwards compatibility with older binary formats
    error[0] = '\0';
    tag      = (CHAR*)buffer;
    *pos    += TAG_LEN;
    result   = ParameterUtils::Read(&size,          buffer, length, pos, 1);
    result   = result && ParameterUtils::Read(&m_version.Value, buffer, length, pos, 1);

    VersionUnion ModeTreeMinVersion(MODE_TREE_MAJOR, MODE_TREE_MINOR, MODE_TREE_PATCH);
    VersionUnion MaxVersion(MAJOR, MINOR, PATCH);
    VersionUnion AlignedVersion(ALIGNED_MAJOR, ALIGNED_MINOR, ALIGNED_PATCH);

    if (m_version >= ModeTreeMinVersion)
    {
        // Tool and Binary Tag are on 8 byte boundaries in the header,
        // so direct casting to char* won't cause pointer alignment issues
        tool      = (CHAR*)(buffer + *pos);
        *pos     += TOOL_LEN;
        binaryTag = (CHAR*)(buffer + *pos);
        *pos     += BINARY_TAG_LEN;
    }

    result = result && ParameterUtils::Read(offset, buffer, length, pos, 1);
    result = result && ParameterUtils::Read(count,  buffer, length, pos, 1);

    if (result)
    {
        if (PARAMETER_STRCMP(tag, TAG) != 0)
        {
            PARAMETER_SPRINTF(error, ERROR_LEN, "Invalid binary header tag: %s", tag);
            SetError(error);
            result = FALSE;
        }
        else if (size > length)
        {
            PARAMETER_SPRINTF(error, ERROR_LEN, "Binary header data too small: Expected: %d bytes, Actual: %u bytes", size, (UINT32)length);
            SetError(error);
            result = FALSE;
        }
        else if (m_version < ModeTreeMinVersion)
        {
            PARAMETER_SPRINTF(error, ERROR_LEN, "Warning: This is an older binary format, only Default mode data is supported.");
            PARAMETER_SPRINTF(error, ERROR_LEN, "To support multiple modes, please re-generate binary using the latest version of Chromatix");
            SetError(error);
        }
        else if (m_version > MaxVersion)
        {
            PARAMETER_SPRINTF(error, ERROR_LEN, "Unsupported binary header version : %u.%u.%u.",
                m_version.Version.Major, m_version.Version.Minor, m_version.Version.Patch);
            PARAMETER_SPRINTF(error, ERROR_LEN, "Please re-generate parser code  using the latest version of Chromatix");
            SetError(error);
            result = FALSE;
        }
    }
    else
    {
        SetError("General error parsing binary header data header");
    }

    // Versions 1.0.x are 1-byte packed
    // Versions 1.1.0 and later are 8 byte aligned
    *alignment = m_version < AlignedVersion ? 1 : 8;

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AddModule
///
/// @brief Updates the module in the module table, or adds new module if not found.
///
/// @param module   Parameter module to add of update
///
/// @return Node
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ParameterSetManager::AddModule(
    ParameterModule* module)
{
    BOOL result = FALSE;

    if (m_rootMode != NULL && module != NULL && module->ModeId < m_modeCount)
    {
        m_modes[module->ModeId].AddModule(module);
        result = TRUE;
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ReadSections
///
/// @brief Reads and validates the the binary parameter file section table
///
/// @param buffer   Binary parameter buffer
/// @param length   Length of the binary parameter buffer
/// @param pos      Current position in the the binary parameter buffer [in/out]
/// @param count    Section count
///
/// @return True if successful
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ParameterSetManager::ReadSections(
    UINT8*      buffer,
    UINT64      length,
    UINT64*     pos,
    UINT32      count,
    IModeTable* modeTable,
    UINT64      alignment)
{
    BOOL result = FALSE;

    if (count >= MIN_SECTIONS && count <= MAX_SECTIONS)
    {
        UINT32 symbolOffset = 0;
        UINT32 symbolSize   = 0;
        UINT32 modeOffset   = 0;
        UINT32 modeSize     = 0;
        UINT32 dataOffset   = 0;
        UINT32 dataSize     = 0;

        result = TRUE;
        for (UINT32 i = 0; result && i < count; i++)
        {
            UINT32 type   = 0;
            UINT32 offset = 0;
            UINT32 size   = 0;

            result = result && ParameterUtils::Read(&type,   buffer, length, pos, alignment);
            result = result && ParameterUtils::Read(&offset, buffer, length, pos, alignment);
            result = result && ParameterUtils::Read(&size,   buffer, length, pos, alignment);
            if (!result)
            {
                SetError("Error reading data from header sections.");
                Valid = FALSE;
            }
            else if (type == SYMBOL_SECTION)
            {
                symbolSize   = size;
                symbolOffset = offset;
            }
            else if (type == DATA_SECTION)
            {
                dataSize   = size;
                dataOffset = offset;
            }
            else if (type == MODE_SECTION)
            {
                modeSize   = size;
                modeOffset = offset;
            }
            else
            {
                SetError("Invalid binary section type.");
                Valid  = FALSE;
                result = FALSE;
            }
        }

        if (result)
        {
            if (modeSize > 0 && modeOffset > 0)
            {
                VersionUnion LinkVersion(LINK_MAJOR, LINK_MINOR, LINK_PATCH);

                // Read Mode Table
                UINT32 entrySize = ParameterFileSymbolTableEntry::MODE_ENTRY_SIZE;
                if (alignment == 1)
                {
                    entrySize = ParameterFileSymbolTableEntry::MODE_ENTRY_SIZE_LEGACY;
                }
                else if (m_version < LinkVersion)
                {
                    entrySize = ParameterFileSymbolTableEntry::MODE_ENTRY_SIZE_NOLINK;
                }
                UINT32 modeCount = modeSize / entrySize;
                UINT32 expected  = modeCount * entrySize;
                BOOL   valid     = modeSize == expected;

                if (valid)
                {
                    UINT64 modePos = (UINT64)modeOffset;
                    m_modes        = PARAMETER_NEW ModeEntry[modeCount];
                    m_modeCount    = modeCount;

                    for (UINT32 i = 0; i < modeCount; i++)
                    {
                        UINT32    id;
                        UINT32    linkId = NOT_LINKED_ID;
                        ModeUnion mode;
                        UINT32    parentID;
                        valid = valid & ParameterUtils::Read(&id,         buffer, length, &modePos, alignment);
                        valid = valid & ParameterUtils::Read(&mode.Value, buffer, length, &modePos, alignment);
                        valid = valid & ParameterUtils::Read(&parentID,   buffer, length, &modePos, alignment);

                        // Read link id from Version 2.x binaries
                        if (m_version >= LinkVersion)
                        {
                            valid = valid & ParameterUtils::Read(&linkId, buffer, length, &modePos, alignment);
                        }

                        if (id >= modeCount)
                        {
                            SetError("Module ID exceeds count");
                            continue;
                        }

                        if (linkId != NOT_LINKED_ID && linkId >= modeCount)
                        {
                            SetError("Link Mode ID exceeds count");
                            continue;
                        }

                        m_modes[id].Initialize(id, mode, linkId != NOT_LINKED_ID ? &m_modes[linkId] : NULL);

                        if (m_rootMode == NULL)
                        {
                            m_rootMode = &m_modes[id];
                        }
                        else
                        {
                            ModeEntry* parent = &m_modes[parentID];
                            if (parent != NULL)
                            {
                                parent->AddMode(&m_modes[id]);
                            }
                            else
                            {
                                valid = FALSE;
                            }
                        }
                    }
                }
            }
            else
            {
                // Create default Mode Table
                m_modes = PARAMETER_NEW ModeEntry[1];
                m_modes[0].Initialize(0, ModeUnion(0), NULL);
                m_rootMode = &m_modes[0];
            }
        }

        if (result && symbolOffset > 0 && symbolSize > 0 && dataOffset > 0 && dataSize > 0)
        {
            ParameterFileSymbolTable symbolTable;
            *pos   = symbolOffset;
            result = result && symbolTable.Load(buffer, length, symbolSize, pos, dataOffset, modeTable, alignment);

            if (result && symbolTable.ModuleCount() > 0)
            {
                UINT32 modules = symbolTable.ModuleCount();

                for (UINT32 i = 0; i < modules; i++)
                {
                    if (!AddModule(CreateModule(symbolTable.GetModule(i), alignment)))
                    {
                        Valid  = FALSE;
                        result = FALSE;
                    }
                }
            }
        }
    }
    else
    {
        SetError("Invalid binary file section count");
        Valid  = FALSE;
        result = FALSE;
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// SetError
///
/// @brief Reports an error
///
/// @param message  Binary parameter buffer
/// @param entry    Symbol table entry containing the error
/// @param module   Parameter module containing the error
///
/// @return None
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ParameterSetManager::SetError(
    const CHAR* message,
    const ParameterFileSymbolTableEntry* entry,
    const ParameterModule* module)
{
    PARAMETER_STRCPY(Error, ERROR_LEN, message);

    if (module != NULL)
    {
        PARAMETER_SPRINTF(Error, ERROR_LEN, "%s Module: %s, Major: %u, Minor: %u, Patch: %u, Mode: %u",
            message, module->Name, module->Version.Version.Major, module->Version.Version.Minor,
            module->Version.Version.Patch, module->Mode.Mode.Mode);
    }
    else if (entry != NULL)
    {
        PARAMETER_SPRINTF(Error, ERROR_LEN, "%s Type: %s, Major: %u, Minor: %u, Patch: %u, Mode: %u",
            message, entry->Type, entry->Version.Version.Major, entry->Version.Version.Minor,
            entry->Version.Version.Patch, entry->Mode.Mode.Mode);
    }
    else
    {
        PARAMETER_STRCPY(Error, ERROR_LEN, message);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// CreateModule
///
/// @brief Creates a new parameter module from a symbol table entry
///
/// @param entry    Symbol table entry
///
/// @return Parameter module
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ParameterModule* ParameterSetManager::CreateModule(
    ParameterFileSymbolTableEntry* entry,
    UINT64 alignment)
{
    ParameterModule*       result = NULL;
    const ParameterModule* module = GetDefaultModule(entry->Type);

    if (module != NULL)
    {
        result = module->Parse(entry, alignment);
        if (result == NULL)
        {
            SetError("Failed to parser binary header data for: ", entry, module);
        }
    }
    else
    {
        SetError("Failed to find header module: ", entry, module);
    }
    return result;
}
